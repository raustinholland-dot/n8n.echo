{
  "id": "RlnZGOaKU4ee7D6M",
  "name": "ECHOv4 - PostgreSQL_TESTING",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyX",
              "value": 1,
              "unit": "minutes"
            }
          ]
        },
        "simple": false,
        "filters": {
          "sender": "austin.holland@clearwatersecurity.com"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1.3,
      "position": [
        -896,
        256
      ],
      "name": "Gmail Trigger - Deal Inputs",
      "alwaysOutputData": false,
      "executeOnce": false,
      "credentials": {
        "gmailOAuth2": {
          "id": "KcxcROH9oa3L7IUB",
          "name": "Gmail ECHO"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Classify input type and extract content\nconst items = $input.all();\nconst results = [];\n\n// Helper: Normalize account name to slug format\nfunction normalizeToSlug(text) {\n  if (!text) return null;\n  return text\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')  // Replace non-alphanumeric with dashes\n    .replace(/^-+|-+$/g, '')      // Trim leading/trailing dashes\n    .replace(/-+/g, '-');          // Collapse multiple dashes\n}\n\nfor (const item of items) {\n  // Check if input is from webhook (MCP) or Gmail\n  const isWebhook = item.json.body !== undefined;\n  \n  let content, subject, input_type, deal_slug, salesforce_opportunity_id, date, source_filename;\n  let opportunity_name, account_name, close_date, trigger_type;\n  \n  if (isWebhook) {\n    // MCP/Webhook input - convert camelCase to snake_case\n    const body = item.json.body;\n    // Generate content from webhook fields if not provided\n    if (body.content) {\n      content = body.content;\n    } else {\n      // Build descriptive content from available fields\n      const parts = [];\n      if (trigger_type && trigger_type !== 'deal_intake') {\n        parts.push(`${trigger_type}`);\n      } else {\n        parts.push('New deal opportunity');\n      }\n      \n      if (opportunity_name) {\n        parts.push(`\"${opportunity_name}\"`);\n      }\n      \n      if (account_name) {\n        parts.push(`at ${account_name}`);\n      }\n      \n      if (close_date) {\n        parts.push(`(expected close: ${close_date})`);\n      }\n      \n      content = parts.join(' ') + '. This is initial deal intake with minimal information.';\n    }\n    input_type = body.input_type || body.inputType || 'call_transcript';\n    opportunity_name = body.opportunity_name || body.opportunityName || null;\n    account_name = body.account_name || body.accountName || null;\n    close_date = body.close_date || body.closeDate || null;\n    trigger_type = body.trigger_type || body.triggerType || 'deal_intake';\n    salesforce_opportunity_id = body.salesforce_opportunity_id || body.salesforceOpportunityId || null;\n    date = body.date || new Date().toISOString().split('T')[0];\n    source_filename = body.source_filename || body.sourceFilename || 'mcp-input';\n    \n    // Slug generation logic:\n    // 1. Use provided slug if exists\n    // 2. Normalize account_name if provided\n    // 3. Fall back to date-based slug\n    if (body.deal_slug || body.dealSlug) {\n      deal_slug = body.deal_slug || body.dealSlug;\n    } else if (account_name) {\n      const accountSlug = normalizeToSlug(account_name);\n      deal_slug = `${accountSlug}-${date}`;\n    } else {\n      deal_slug = `deal-${date}`;\n    }\n    \n  } else {\n    // Gmail input\n    subject = item.json.subject || '';\n    const text = item.json.text || item.json.textPlain || '';\n    content = text;\n    \n    // Check for X-ECHO-Deal-Slug header first (most reliable)\n    const headers = item.json.headers || {};\n    const echoSlugHeader = headers['x-echo-deal-slug'] || headers['X-ECHO-Deal-Slug'] || headers['X-Echo-Deal-Slug'];\n    \n    if (echoSlugHeader) {\n      deal_slug = echoSlugHeader;\n    } else {\n      // Strip email prefixes (Re:, Fwd:, FW:, etc.) then extract account name\n      const cleanSubject = subject.replace(/^(Re:|Fwd:|FW:|RE:|FWD:)\\s*/gi, '').trim();\n      const subjectMatch = cleanSubject.match(/^([^-]+)/);\n      if (subjectMatch) {\n        const extractedAccount = subjectMatch[1].trim();\n        account_name = extractedAccount;\n        deal_slug = `${normalizeToSlug(extractedAccount)}-${new Date().toISOString().split('T')[0]}`;\n      } else {\n        deal_slug = `deal-${new Date().toISOString().split('T')[0]}`;\n      }\n    }\n    \n    // Determine input type\n    input_type = 'email';\n    if (subject.toLowerCase().includes('transcript')) {\n      input_type = 'call_transcript';\n    } else if (subject.toLowerCase().includes('notes')) {\n      input_type = 'call_notes';\n    }\n    \n    salesforce_opportunity_id = null;\n    date = new Date().toISOString().split('T')[0];\n    source_filename = `email-${item.json.id || 'unknown'}`;\n    opportunity_name = null;\n    close_date = null;\n    trigger_type = 'email_trigger';\n  }\n  \n  results.push({\n    json: {\n      content: content,\n      subject: subject,\n      input_type: input_type,\n      deal_slug: deal_slug,\n      salesforce_opportunity_id: salesforce_opportunity_id,\n      date: date,\n      source_filename: source_filename,\n      opportunity_name: opportunity_name,\n      account_name: account_name,\n      close_date: close_date,\n      trigger_type: trigger_type\n    }\n  });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        160
      ],
      "name": "Input Classifier"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM deals \nWHERE salesforce_opportunity_id = '{{ $json.salesforce_opportunity_id }}'\n   OR deal_slug = '{{ $json.deal_slug }}'\n   OR (account_name IS NOT NULL \n       AND account_name ILIKE '{{ $json.account_name }}%')\nORDER BY \n  CASE \n    WHEN deal_slug = '{{ $json.deal_slug }}' THEN 1\n    WHEN salesforce_opportunity_id = '{{ $json.salesforce_opportunity_id }}' THEN 2\n    ELSE 3\n  END,\n  updated_at DESC\nLIMIT 1",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -464,
        160
      ],
      "name": "Load Deal Memory",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      },
      "continueOnFail": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\n// Get input data using correct n8n syntax\nconst inputData = $('Input Classifier').item.json;\n\n// Check what we got from Load Deal Memory\nconst dealData = items?.[0]?.json;\nconst idValue = dealData?.id;\n\n// Check for valid deal - id must be a positive number\nconst hasValidDeal = typeof idValue === 'number' && idValue > 0;\n\nif (!hasValidDeal) {\n  // No valid deal\n  return [{ \n    json: { \n      _noDealsFound: true,\n      _contextSource: 'new_opportunity',\n      deal_slug: inputData.deal_slug,\n      opportunity_name: inputData.opportunity_name,\n      account_name: inputData.account_name,\n      close_date: inputData.close_date,\n      salesforce_opportunity_id: inputData.salesforce_opportunity_id,\n      trigger_type: inputData.trigger_type,\n      content: inputData.content,\n      input_type: inputData.input_type\n    }\n  }];\n}\n\n// Deal found\nreturn [{ \n  json: {\n    ...dealData,\n    _noDealsFound: false,\n    _contextSource: 'existing_deal',\n    content: inputData.content\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        32
      ],
      "name": "Validate Deal Memory",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Format outputs from both ECHO agents for PostgreSQL and review portal\nconst agent1 = $('ECHO Pass 3 - Artifacts').item.json;\nconst agent2 = $('ECHO Pass 3 - Artifacts').item.json;\nconst input = $('Input Classifier').item.json;\nconst dealContext = $('Merge Deal Context').item.json;\n\nif (!agent1 || !input) {\n  throw new Error('Missing required data from ECHO Intelligence Engine or Input Classifier');\n}\n\nfunction esc(val) {\n  if (val === null || val === undefined || val === '') return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction escStr(val) {\n  if (val === null || val === undefined) return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction escNum(val) {\n  const n = Number(val);\n  return isNaN(n) ? '0' : String(n);\n}\n\nfunction unwrap(node) {\n  const raw = node.output !== undefined ? node.output : node;\n  if (typeof raw === 'string') {\n    try {\n      const cleaned = raw.replace(/^```json\\s*/i, '').replace(/^```\\s*/i, '').replace(/```\\s*$/i, '').trim();\n      return JSON.parse(cleaned);\n    } catch(e) { return {}; }\n  }\n  return raw;\n}\n\nconst data1 = unwrap(agent1);\nconst sf = data1.salesforce || {};\n\nconst data2 = unwrap(agent2);\nconst narr = data2.narratives || {};\n\nfunction extractStageCode(casStr) {\n  if (!casStr) return '1A';\n  const match = casStr.match(/^([1-5][AB])/i);\n  if (match) return match[1].toUpperCase();\n  const s = casStr.toLowerCase();\n  if (s.includes('close') || s.includes('won') || s.includes('lost')) return '5A';\n  if (s.includes('negot') || s.includes('contract') || s.includes('msa') || s.includes('sow')) return '4A';\n  if (s.includes('prov') || s.includes('valid') || s.includes('proposal') || s.includes('demo')) return '3A';\n  if (s.includes('qualif') || s.includes('engaged') || s.includes('discover')) return '2A';\n  return '1A';\n}\n\nconst deal_slug = input.deal_slug || '';\nconst salesforce_opportunity_id = dealContext?.salesforce_opportunity_id || input.salesforce_opportunity_id || null;\nconst opportunity_name = input.opportunity_name || dealContext?.opportunity_name || '';\nconst account_name = input.account_name || dealContext?.account_name || '';\n\nconst close_date = sf.close_date || null;\nconst stage = sf.stage || '';\nconst cas = sf.cas || '';\nconst forecast_category = sf.forecast_category || '';\nconst salesforce_block_1_dap = sf.salesforce_block_1_dap || '';\nconst risks = sf.risks || '';\nconst next_step = sf.next_step || '';\n\nconst pain_score = Number(sf.pain_score) || 0;\nconst pain_evidence = sf.pain_evidence || '';\nconst power_score = Number(sf.power_score) || 0;\nconst power_evidence = sf.power_evidence || '';\nconst vision_score = Number(sf.vision_score) || 0;\nconst vision_evidence = sf.vision_evidence || '';\nconst value_score = Number(sf.value_score) || 0;\nconst value_evidence = sf.value_evidence || '';\nconst change_score = Number(sf.change_score) || 0;\nconst change_evidence = sf.change_evidence || '';\nconst control_score = Number(sf.control_score) || 0;\nconst control_evidence = sf.control_evidence || '';\nconst p2v2c2_total = pain_score + power_score + vision_score + value_score + change_score + control_score;\n\nconst call_summary = narr.call_summary || '';\nconst highlights = narr.highlights || '';\nconst action_items = narr.action_items || '';\nconst p2v2c2_scoring = narr.p2v2c2_scoring || '';\nconst internal_actions = narr.internal_actions || '';\nconst services_narrative = narr.services_narrative || '';\nconst general_narrative = narr.general_narrative || '';\nconst anecdotes = narr.anecdotes || '';\nconst internal_team_update = narr.internal_team_update || '';\n\nconst stage_code = extractStageCode(cas);\nconst cas_confidence = 'medium';\nconst event_type = input.input_type || '';\nconst event_date = input.date || new Date().toISOString().split('T')[0];\nconst summary_str = `Processed ${input.input_type} - CAS: ${cas || 'N/A'}`;\nconst link_or_ref = input.source_filename || '';\nconst raw_content = (input.content || '').substring(0, 5000);\n\nconst insertDealSQL = `INSERT INTO deals (\n  deal_slug, salesforce_opportunity_id, outputs_version,\n  opportunity_name, account_name, stage, cas_current, cas_next, cas_confidence,\n  pain_score, power_score, vision_score, value_score, change_score, control_score\n) VALUES (\n  ${esc(deal_slug)}, ${esc(salesforce_opportunity_id)}, 'v4',\n  ${escStr(opportunity_name)}, ${escStr(account_name)}, ${escStr(stage_code)},\n  ${escStr(cas)}, ${escStr('')}, ${escStr(cas_confidence)},\n  ${escNum(pain_score)}, ${escNum(power_score)}, ${escNum(vision_score)},\n  ${escNum(value_score)}, ${escNum(change_score)}, ${escNum(control_score)}\n)\nON CONFLICT (deal_slug) DO UPDATE SET\n  salesforce_opportunity_id = EXCLUDED.salesforce_opportunity_id,\n  outputs_version = EXCLUDED.outputs_version,\n  opportunity_name = EXCLUDED.opportunity_name,\n  account_name = EXCLUDED.account_name,\n  stage = EXCLUDED.stage,\n  cas_current = EXCLUDED.cas_current,\n  cas_confidence = EXCLUDED.cas_confidence,\n  pain_score = EXCLUDED.pain_score,\n  power_score = EXCLUDED.power_score,\n  vision_score = EXCLUDED.vision_score,\n  value_score = EXCLUDED.value_score,\n  change_score = EXCLUDED.change_score,\n  control_score = EXCLUDED.control_score,\n  updated_at = CURRENT_TIMESTAMP\nRETURNING id`;\n\nconst updateDealSQL = `UPDATE deals SET\n  salesforce_opportunity_id = ${esc(salesforce_opportunity_id)},\n  outputs_version = 'v4',\n  opportunity_name = ${escStr(opportunity_name)},\n  account_name = ${escStr(account_name)},\n  stage = ${escStr(stage_code)},\n  cas_current = ${escStr(cas)},\n  cas_confidence = ${escStr(cas_confidence)},\n  close_date = ${close_date ? escStr(close_date) : 'NULL'},\n  updated_at = CURRENT_TIMESTAMP\nWHERE deal_slug = ${esc(deal_slug)}\nRETURNING *`;\n\nconst saveArtifactsSQL = `INSERT INTO artifacts (\n  deal_id,\n  salesforce_block_1_dap,\n  salesforce_pain_description, salesforce_power_description,\n  salesforce_vision_description, salesforce_value_description,\n  salesforce_change_description, salesforce_control_description,\n  approved\n) VALUES (\n  (SELECT id FROM deals WHERE deal_slug = ${esc(deal_slug)}),\n  ${esc(salesforce_block_1_dap)},\n  ${esc(pain_evidence)}, ${esc(power_evidence)},\n  ${esc(vision_evidence)}, ${esc(value_evidence)},\n  ${esc(change_evidence)}, ${esc(control_evidence)},\n  false\n)\nRETURNING id`;\n\nconst saveEvidenceSQL = `INSERT INTO p2v2c2_evidence (\n  deal_id, pain_score, pain_evidence, power_score, power_evidence,\n  vision_score, vision_evidence, value_score, value_evidence,\n  change_score, change_evidence, control_score, control_evidence, p2v2c2_total\n) VALUES (\n  (SELECT id FROM deals WHERE deal_slug = ${esc(deal_slug)}),\n  ${escNum(pain_score)}, ${esc(pain_evidence)},\n  ${escNum(power_score)}, ${esc(power_evidence)},\n  ${escNum(vision_score)}, ${esc(vision_evidence)},\n  ${escNum(value_score)}, ${esc(value_evidence)},\n  ${escNum(change_score)}, ${esc(change_evidence)},\n  ${escNum(control_score)}, ${esc(control_evidence)},\n  ${escNum(p2v2c2_total)}\n)\nRETURNING id`;\n\nconst saveHistorySQL = `INSERT INTO deal_history (\n  deal_id, event_type, event_source, event_date, summary,\n  link_or_ref, raw_content, cas_at_time, p2v2c2_total_at_time\n) VALUES (\n  (SELECT id FROM deals WHERE deal_slug = ${esc(deal_slug)}),\n  ${escStr(event_type)}, ${esc('')}, ${escStr(event_date)}::date,\n  ${escStr(summary_str)}, ${esc(link_or_ref)}, ${escStr(raw_content)},\n  ${escStr(cas)}, ${escNum(p2v2c2_total)}\n)\nRETURNING id`;\n\nconst deal = {\n  deal_slug, salesforce_opportunity_id, outputs_version: 'v4',\n  opportunity_name, account_name, stage: stage_code,\n  cas_current: cas, cas_next: '', cas_confidence, close_date,\n  pain_score, power_score, vision_score, value_score, change_score, control_score\n};\n\nreturn [{\n  json: {\n    deal,\n    _contextSource: dealContext?._contextSource || 'unknown',\n    insertDealSQL, updateDealSQL, saveArtifactsSQL, saveEvidenceSQL, saveHistorySQL,\n    close_date, stage, cas, forecast_category,\n    salesforce_block_1_dap, risks, next_step,\n    pain_score, pain_evidence,\n    power_score, power_evidence,\n    vision_score, vision_evidence,\n    value_score, value_evidence,\n    change_score, change_evidence,\n    control_score, control_evidence,\n    p2v2c2_total,\n    call_summary, highlights, action_items, p2v2c2_scoring,\n    internal_actions, services_narrative, general_narrative,\n    anecdotes, internal_team_update\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1424,
        64
      ],
      "name": "Format for PostgreSQL"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://host.docker.internal:5679/receive",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"execution_id\": \"{{ $execution.id }}\"\n}",
        "options": {
          "timeout": 5000,
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        800,
        280
      ],
      "name": "Open Review Portal"
    },
    {
      "parameters": {
        "resume": "form",
        "formTitle": "Review & Edit Deal Artifacts",
        "formDescription": "Review and edit AI-generated artifacts before saving. Leave any field blank to keep the AI original. Check the Review Required email for the pre-filled content to copy in.",
        "formFields": {
          "values": [
            {
              "fieldLabel": "close_date",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.close_date }}"
            },
            {
              "fieldLabel": "stage",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.stage }}"
            },
            {
              "fieldLabel": "cas",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.cas }}"
            },
            {
              "fieldLabel": "forecast_category",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.forecast_category }}"
            },
            {
              "fieldLabel": "salesforce_block_1_dap",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.salesforce_block_1_dap }}"
            },
            {
              "fieldLabel": "risks",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.risks }}"
            },
            {
              "fieldLabel": "next_step",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.next_step }}"
            },
            {
              "fieldLabel": "pain_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.pain_score }}"
            },
            {
              "fieldLabel": "pain_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.pain_evidence }}"
            },
            {
              "fieldLabel": "power_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.power_score }}"
            },
            {
              "fieldLabel": "power_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.power_evidence }}"
            },
            {
              "fieldLabel": "vision_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.vision_score }}"
            },
            {
              "fieldLabel": "vision_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.vision_evidence }}"
            },
            {
              "fieldLabel": "value_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.value_score }}"
            },
            {
              "fieldLabel": "value_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.value_evidence }}"
            },
            {
              "fieldLabel": "change_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.change_score }}"
            },
            {
              "fieldLabel": "change_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.change_evidence }}"
            },
            {
              "fieldLabel": "control_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.control_score }}"
            },
            {
              "fieldLabel": "control_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.control_evidence }}"
            },
            {
              "fieldLabel": "call_summary",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.call_summary }}"
            },
            {
              "fieldLabel": "highlights",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.highlights }}"
            },
            {
              "fieldLabel": "action_items",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.action_items }}"
            },
            {
              "fieldLabel": "p2v2c2_scoring",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.p2v2c2_scoring }}"
            },
            {
              "fieldLabel": "internal_actions",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.internal_actions }}"
            },
            {
              "fieldLabel": "services_narrative",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.services_narrative }}"
            },
            {
              "fieldLabel": "general_narrative",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.general_narrative }}"
            },
            {
              "fieldLabel": "anecdotes",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.anecdotes }}"
            },
            {
              "fieldLabel": "internal_team_update",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.internal_team_update }}"
            }
          ]
        },
        "responseMode": "onReceived",
        "options": {
          "responseText": "Artifacts saved. Check your email for the final output."
        }
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        1000,
        64
      ],
      "name": "Wait for Review (Editing Portal)",
      "webhookId": "echo-artifact-review"
    },
    {
      "parameters": {
        "jsCode": "// Merge original AI outputs with edits from the review form\nconst orig = $('Format for PostgreSQL').item.json;\nconst form = $input.item.json;\n\nfunction esc(val) {\n  if (val === null || val === undefined || val === '') return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction escStr(val) {\n  if (val === null || val === undefined) return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction escNum(val) {\n  const n = Number(val);\n  return isNaN(n) ? '0' : String(n);\n}\nfunction extractStageCode(casStr) {\n  if (!casStr) return '1A';\n  const s = String(casStr);\n  const match = s.match(/^([1-5][AB])/i);\n  if (match) return match[1].toUpperCase();\n  const sl = s.toLowerCase();\n  if (sl.includes('close') || sl.includes('won') || sl.includes('lost')) return '5A';\n  if (sl.includes('negot') || sl.includes('contract') || sl.includes('msa') || sl.includes('sow')) return '4A';\n  if (sl.includes('prov') || sl.includes('valid') || sl.includes('proposal') || sl.includes('demo')) return '3A';\n  if (sl.includes('qualif') || sl.includes('engaged') || sl.includes('discover')) return '2A';\n  return '1A';\n}\n\nfunction edited(formVal, origVal) {\n  const f = (formVal || '').trim();\n  return f.length > 0 ? f : (origVal || '');\n}\nfunction editedNum(formVal, origVal) {\n  const f = String(formVal || '').trim();\n  const n = Number(f);\n  return (!isNaN(n) && f.length > 0) ? n : origVal;\n}\n\n// Salesforce standalone\nconst close_date = edited(form['close_date'], orig.close_date);\nconst stage = edited(form['stage'], orig.stage);\nconst cas = edited(form['cas'], orig.cas);\nconst forecast_category = edited(form['forecast_category'], orig.forecast_category);\nconst salesforce_block_1_dap = edited(form['salesforce_block_1_dap'], orig.salesforce_block_1_dap);\nconst risks = edited(form['risks'], orig.risks);\nconst next_step = edited(form['next_step'], orig.next_step);\n\n// P2V2C2\nconst pain_score = editedNum(form['pain_score'], orig.pain_score);\nconst pain_evidence = edited(form['pain_evidence'], orig.pain_evidence);\nconst power_score = editedNum(form['power_score'], orig.power_score);\nconst power_evidence = edited(form['power_evidence'], orig.power_evidence);\nconst vision_score = editedNum(form['vision_score'], orig.vision_score);\nconst vision_evidence = edited(form['vision_evidence'], orig.vision_evidence);\nconst value_score = editedNum(form['value_score'], orig.value_score);\nconst value_evidence = edited(form['value_evidence'], orig.value_evidence);\nconst change_score = editedNum(form['change_score'], orig.change_score);\nconst change_evidence = edited(form['change_evidence'], orig.change_evidence);\nconst control_score = editedNum(form['control_score'], orig.control_score);\nconst control_evidence = edited(form['control_evidence'], orig.control_evidence);\nconst p2v2c2_total = pain_score + power_score + vision_score + value_score + change_score + control_score;\n\n// Narratives\nconst call_summary = edited(form['call_summary'], orig.call_summary);\nconst highlights = edited(form['highlights'], orig.highlights);\nconst action_items = edited(form['action_items'], orig.action_items);\nconst p2v2c2_scoring = edited(form['p2v2c2_scoring'], orig.p2v2c2_scoring);\nconst internal_actions = edited(form['internal_actions'], orig.internal_actions);\nconst services_narrative = edited(form['services_narrative'], orig.services_narrative);\nconst general_narrative = edited(form['general_narrative'], orig.general_narrative);\nconst anecdotes = edited(form['anecdotes'], orig.anecdotes);\nconst internal_team_update = edited(form['internal_team_update'], orig.internal_team_update);\n\nconst deal_slug = orig.deal.deal_slug;\nconst salesforce_opportunity_id = orig.deal.salesforce_opportunity_id || null;\nconst opportunity_name = orig.deal.opportunity_name || '';\nconst account_name = orig.deal.account_name || '';\nconst stage_code = extractStageCode(cas);\nconst cas_confidence = orig.deal.cas_confidence || 'medium';\nconst _contextSource = orig._contextSource || 'unknown';\n\n// Re-build input fields needed for evidence/history SQL\nconst input = $('Input Classifier').item.json;\nconst event_type = input.input_type || '';\nconst event_date = input.date || new Date().toISOString().split('T')[0];\nconst summary_str = `Processed ${input.input_type} - CAS: ${cas || 'N/A'}`;\nconst link_or_ref = input.source_filename || '';\nconst raw_content = (input.content || '').substring(0, 5000);\n\nconst insertDealSQL = `INSERT INTO deals (\n  deal_slug, salesforce_opportunity_id, outputs_version,\n  opportunity_name, account_name, stage, cas_current, cas_next, cas_confidence,\n  pain_score, power_score, vision_score, value_score, change_score, control_score\n) VALUES (\n  ${esc(deal_slug)}, ${esc(salesforce_opportunity_id)}, 'v4',\n  ${escStr(opportunity_name)}, ${escStr(account_name)}, ${escStr(stage_code)},\n  ${escStr(cas)}, ${escStr('')}, ${escStr(cas_confidence)},\n  ${escNum(pain_score)}, ${escNum(power_score)}, ${escNum(vision_score)},\n  ${escNum(value_score)}, ${escNum(change_score)}, ${escNum(control_score)}\n)\nON CONFLICT (deal_slug) DO UPDATE SET\n  salesforce_opportunity_id = EXCLUDED.salesforce_opportunity_id,\n  outputs_version = EXCLUDED.outputs_version,\n  opportunity_name = EXCLUDED.opportunity_name,\n  account_name = EXCLUDED.account_name,\n  stage = EXCLUDED.stage,\n  cas_current = EXCLUDED.cas_current,\n  cas_confidence = EXCLUDED.cas_confidence,\n  pain_score = EXCLUDED.pain_score,\n  power_score = EXCLUDED.power_score,\n  vision_score = EXCLUDED.vision_score,\n  value_score = EXCLUDED.value_score,\n  change_score = EXCLUDED.change_score,\n  control_score = EXCLUDED.control_score,\n  updated_at = CURRENT_TIMESTAMP\nRETURNING id`;\n\nconst updateDealSQL = `UPDATE deals SET\n  salesforce_opportunity_id = ${esc(salesforce_opportunity_id)},\n  outputs_version = 'v4',\n  opportunity_name = ${escStr(opportunity_name)},\n  account_name = ${escStr(account_name)},\n  stage = ${escStr(stage_code)},\n  cas_current = ${escStr(cas)},\n  cas_confidence = ${escStr(cas_confidence)},\n  close_date = ${close_date ? escStr(close_date) : 'NULL'},\n  pain_score = ${escNum(pain_score)},\n  power_score = ${escNum(power_score)},\n  vision_score = ${escNum(vision_score)},\n  value_score = ${escNum(value_score)},\n  change_score = ${escNum(change_score)},\n  control_score = ${escNum(control_score)},\n  updated_at = CURRENT_TIMESTAMP\nWHERE deal_slug = ${esc(deal_slug)}\nRETURNING *`;\n\nconst saveArtifactsSQL = `INSERT INTO artifacts (\n  deal_id,\n  salesforce_block_1_dap,\n  salesforce_pain_description, salesforce_power_description,\n  salesforce_vision_description, salesforce_value_description,\n  salesforce_change_description, salesforce_control_description,\n  approved\n) VALUES (\n  (SELECT id FROM deals WHERE deal_slug = ${esc(deal_slug)}),\n  ${esc(salesforce_block_1_dap)},\n  ${esc(pain_evidence)}, ${esc(power_evidence)},\n  ${esc(vision_evidence)}, ${esc(value_evidence)},\n  ${esc(change_evidence)}, ${esc(control_evidence)},\n  false\n)\nRETURNING id`;\n\nconst saveEvidenceSQL = `INSERT INTO p2v2c2_evidence (\n  deal_id, pain_score, pain_evidence, power_score, power_evidence,\n  vision_score, vision_evidence, value_score, value_evidence,\n  change_score, change_evidence, control_score, control_evidence, p2v2c2_total\n) VALUES (\n  (SELECT id FROM deals WHERE deal_slug = ${esc(deal_slug)}),\n  ${escNum(pain_score)}, ${esc(pain_evidence)},\n  ${escNum(power_score)}, ${esc(power_evidence)},\n  ${escNum(vision_score)}, ${esc(vision_evidence)},\n  ${escNum(value_score)}, ${esc(value_evidence)},\n  ${escNum(change_score)}, ${esc(change_evidence)},\n  ${escNum(control_score)}, ${esc(control_evidence)},\n  ${escNum(p2v2c2_total)}\n)\nRETURNING id`;\n\nconst saveHistorySQL = `INSERT INTO deal_history (\n  deal_id, event_type, event_source, event_date, summary,\n  link_or_ref, raw_content, cas_at_time, p2v2c2_total_at_time\n) VALUES (\n  (SELECT id FROM deals WHERE deal_slug = ${esc(deal_slug)}),\n  ${escStr(event_type)}, ${esc('')}, ${escStr(event_date)}::date,\n  ${escStr(summary_str)}, ${esc(link_or_ref)}, ${escStr(raw_content)},\n  ${escStr(cas)}, ${escNum(p2v2c2_total)}\n)\nRETURNING id`;\n\nreturn [{\n  json: {\n    deal: orig.deal,\n    _contextSource,\n    insertDealSQL, updateDealSQL, saveArtifactsSQL, saveEvidenceSQL, saveHistorySQL,\n    close_date, stage, cas, forecast_category,\n    salesforce_block_1_dap, risks, next_step,\n    pain_score, pain_evidence,\n    power_score, power_evidence,\n    vision_score, vision_evidence,\n    value_score, value_evidence,\n    change_score, change_evidence,\n    control_score, control_evidence,\n    p2v2c2_total,\n    call_summary, highlights, action_items, p2v2c2_scoring,\n    internal_actions, services_narrative, general_narrative,\n    anecdotes, internal_team_update\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        64
      ],
      "name": "Merge Edited Artifacts"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "check-new-opp-id",
              "leftValue": "={{ $json._contextSource?.toLowerCase().trim() }}",
              "operator": {
                "type": "string",
                "operation": "contains",
                "singleValue": "new"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1120,
        64
      ],
      "name": "Check if New Deal"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.insertDealSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1280,
        -32
      ],
      "name": "Insert New Deal",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.updateDealSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1280,
        160
      ],
      "name": "Update Existing Deal",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Merge Edited Artifacts').item.json.saveArtifactsSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1440,
        64
      ],
      "name": "Save Artifacts",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Merge Edited Artifacts').item.json.saveFeedbackSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1440,
        208
      ],
      "name": "Save Artifact Feedback",
      "continueOnFail": true,
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Merge Edited Artifacts').item.json.saveEvidenceSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1584,
        64
      ],
      "name": "Save P2V2C2 Evidence",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Merge Edited Artifacts').item.json.saveHistorySQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1728,
        64
      ],
      "name": "Save History",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge both trigger sources\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -752,
        160
      ],
      "name": "Merge Triggers"
    },
    {
      "parameters": {
        "sendTo": "austin.holland@clearwatersecurity.com",
        "subject": "Deal Path Artifacts Notification",
        "message": "=<h2>Deal Path Artifacts \u2014 Final (Reviewed)</h2>\n\n<p><strong>Deal:</strong> {{ $('Merge Edited Artifacts').item.json.deal.deal_slug }}</p>\n<p><strong>Opportunity:</strong> {{ $('Merge Edited Artifacts').item.json.deal.opportunity_name }}</p>\n<p><strong>Date:</strong> {{ $('Input Classifier').item.json.date }}</p>\n<p><strong>Input Type:</strong> {{ $('Input Classifier').item.json.input_type }}</p>\n\n<h3>CAS Stage</h3>\n<p><strong>Current:</strong> {{ $('Merge Edited Artifacts').item.json.deal.cas_current }}</p>\n<p><strong>Next:</strong> {{ $('Merge Edited Artifacts').item.json.deal.cas_next }}</p>\n\n<hr>\n\n<h3>Artifacts (Reviewed &amp; Approved)</h3>\n\n<h4>Client Follow-Up Email</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">{{ $('Merge Edited Artifacts').item.json.client_follow_up_email }}</pre>\n\n<h4>Salesforce DAP Block</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">{{ $('Merge Edited Artifacts').item.json.salesforce_block_1_dap }}</pre>\n\n<h4>Salesforce P2V2C2</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">Pain ({{ $('Merge Edited Artifacts').item.json.pain_score }}/5): {{ $('Merge Edited Artifacts').item.json.pain_evidence }}\n\nPower ({{ $('Merge Edited Artifacts').item.json.power_score }}/5): {{ $('Merge Edited Artifacts').item.json.power_evidence }}\n\nVision ({{ $('Merge Edited Artifacts').item.json.vision_score }}/5): {{ $('Merge Edited Artifacts').item.json.vision_evidence }}\n\nValue ({{ $('Merge Edited Artifacts').item.json.value_score }}/5): {{ $('Merge Edited Artifacts').item.json.value_evidence }}\n\nChange ({{ $('Merge Edited Artifacts').item.json.change_score }}/5): {{ $('Merge Edited Artifacts').item.json.change_evidence }}\n\nControl ({{ $('Merge Edited Artifacts').item.json.control_score }}/5): {{ $('Merge Edited Artifacts').item.json.control_evidence }}\n\nTotal: {{ $('Merge Edited Artifacts').item.json.p2v2c2_total }}/30</pre>\n\n<h4>Executive Recap</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">{{ $('Merge Edited Artifacts').item.json.exec_recap_forwardable }}</pre>\n\n<h4>Internal Message - Pricing</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">{{ $('Merge Edited Artifacts').item.json.internal_message_pricing }}</pre>",
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        1872,
        160
      ],
      "name": "Gmail - Send Artifacts Email",
      "webhookId": "d41f4808-1611-40bf-b933-cb7ec9b596ad",
      "credentials": {
        "gmailOAuth2": {
          "id": "KcxcROH9oa3L7IUB",
          "name": "Gmail ECHO"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "check-deal-found",
              "leftValue": "={{ $json._contextSource?.toLowerCase().trim() }}",
              "operator": {
                "type": "string",
                "operation": "contains",
                "singleValue": "existing"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -288,
        240
      ],
      "name": "Check Deal Exists"
    },
    {
      "parameters": {
        "jsCode": "// Initialize a new opportunity when deal doesn't exist\nconst input = $('Input Classifier').item.json;\n\nconst newDeal = {\n  json: {\n    kind: 'deal_record',\n    deal_slug: input.deal_slug,\n    salesforce_opportunity_id: null,\n    _contextSource: 'new_opportunity',\n    outputs_version: 'v2',\n    content: input.content || `New deal opportunity: ${input.opportunity_name || 'unnamed'} at ${input.account_name || 'unknown account'}. Expected close: ${input.close_date || 'TBD'}`,\n    input_type: input.input_type || 'deal_intake',\n    \n    updated_at: new Date().toISOString(),\n    \n    opportunity_name: '',\n    account_name: '',\n    cas_current: '1A: Discovery - Initial conversation',\n    cas_next: '1B: Discovery - Problem validation',\n    cas_confidence: 'low',\n    \n    pain_score: 0,\n    power_score: 0,\n    vision_score: 0,\n    value_score: 0,\n    change_score: 0,\n    control_score: 0\n  }\n};\n\nreturn [newDeal];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        224
      ],
      "name": "Create New Opportunity",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst dealContext = items[0];\nconst contextSource = dealContext.json._contextSource || 'unknown';\n\nconsole.log('Merge Deal Context - contextSource:', contextSource);\n\nreturn [{\n  json: {\n    ...dealContext.json,\n    _contextSource: contextSource\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        80
      ],
      "name": "Merge Deal Context"
    },
    {
      "parameters": {
        "model": "text-embedding-3-small",
        "options": {
          "baseURL": "https://api.openai.com/v1"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1,
      "position": [
        240,
        560
      ],
      "name": "OpenAI Embeddings",
      "credentials": {
        "openAiApi": {
          "id": "fIeGh1UabUL1CBma",
          "name": "ECHO OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "mode": "retrieve-as-tool",
        "toolName": "clearwater_knowledge_base",
        "toolDescription": "Search Clearwater's CPS methodology (P2V2C2 scoring rubric 0-5 definitions, DAP structure, sales stages Discover/Qualify/Prove/Negotiate/Close, Champion/PES/ES/DM role definitions) and Clearwater's full service catalog (MSS, MDR, Risk Analysis, IRM|Pro, ClearAdvantage, vCISO, Privacy & Compliance, Technical Testing, etc.). Use this tool to look up scoring criteria, service terminology, and sales process definitions.",
        "tableName": "n8n_vectors",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePGVector",
      "typeVersion": 1.3,
      "position": [
        240,
        480
      ],
      "name": "ECHO Knowledge Base (PGVector)",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.content }}",
        "options": {
          "systemMessage": "IDENTITY\nYou are ECHO Pass 1 \u2014 The Delta Specialist. You are the first pass in a three-pass deal analysis system. Your job is to extract only what is NEW from the current input by comparing it against the prior deal state. You do not score. You do not generate artifacts. You extract and compare.\n\nYou will receive two things:\n1. PRIOR DEAL STATE \u2014 what is already known about this deal (scores, CAS, evidence, history)\n2. NEW INPUT \u2014 the raw transcript, email, or notes from the current interaction\n\nSTEP 1 \u2014 IDENTIFY SPEAKERS\nBefore extracting evidence, identify every speaker in the new input.\n\nRules:\n- Look for explicit name mentions (\"Hi, I'm Sarah\", \"Austin here\")\n- Look for role signals (\"our CEO\", \"our IT director\", \"I report to the board\")\n- Look for first-person context clues (\"we have 200 employees\", \"our MSP handles that\")\n- Austin Holland is always the Clearwater rep \u2014 label him \"Austin (Clearwater)\"\n- If a speaker cannot be identified by name, label by role (e.g., \"Client IT Director\") or \"Client (Unknown)\" \u2014 never just \"Unknown\"\n- List every identified speaker with name, role, and company\n\nSTEP 2 \u2014 DELTA EXTRACTION\nCompare the new input against the prior deal state. Extract ONLY what is new or changed.\n\nFor each P2V2C2 dimension, ask:\n- Is there a NEW admission of pain not present in prior history?\n- Is there a NEW signal of power or access not previously confirmed?\n- Has the client expressed a NEW vision statement or desired future state?\n- Has a NEW cost, ROI, or value justification been articulated?\n- Has there been a NEW commitment to change or urgency signal?\n- Have NEW buying process details, timelines, or approval steps been revealed?\n\nRules:\n- Verbatim quotes ONLY \u2014 no paraphrase, no interpretation\n- Every quote attributed to a named speaker from Step 1\n- If a dimension has no NEW evidence (it was already known), write \"No new evidence \u2014 see prior state\"\n- If this is the first run (no prior state), treat all evidence as new\n- Also extract any NEW DAP dates or milestones explicitly discussed in the input\n\nSTEP 3 \u2014 PRIOR STATE SUMMARY\nSummarize the prior deal state in one block so Pass 2 has full context:\n- Prior CAS and stage\n- Prior P2V2C2 scores (all 6)\n- Key prior evidence already on record\n\nOUTPUT FORMAT\nReturn ONLY the following JSON \u2014 no preamble, no markdown fences:\n{\n  \"speakers\": [\n    {\"name\": \"\", \"role\": \"\", \"company\": \"\"}\n  ],\n  \"is_first_run\": true,\n  \"prior_state\": {\n    \"cas\": \"\",\n    \"stage\": \"\",\n    \"pain_score\": 0,\n    \"power_score\": 0,\n    \"vision_score\": 0,\n    \"value_score\": 0,\n    \"change_score\": 0,\n    \"control_score\": 0,\n    \"summary\": \"\"\n  },\n  \"new_delta\": {\n    \"pain\": \"\",\n    \"power\": \"\",\n    \"vision\": \"\",\n    \"value\": \"\",\n    \"change\": \"\",\n    \"control\": \"\",\n    \"dap_dates_mentioned\": \"\"\n  }\n}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        384,
        64
      ],
      "name": "ECHO Pass 1 - Evidence",
      "alwaysOutputData": true,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        384,
        288
      ],
      "name": "GPT-4o Pass 1",
      "credentials": {
        "openAiApi": {
          "id": "fIeGh1UabUL1CBma",
          "name": "ECHO OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Handoff: Pass 1 Delta \u2192 Pass 2 Scoring\nconst pass1 = $('ECHO Pass 1 - Evidence').item.json;\nconst dealContext = $('Merge Deal Context').item.json;\n\nfunction unwrap(node) {\n  const raw = node.output !== undefined ? node.output : node;\n  if (typeof raw === 'string') {\n    try {\n      const cleaned = raw.replace(/^```json\\s*/i, '').replace(/^```\\s*/i, '').replace(/```\\s*$/i, '').trim();\n      return JSON.parse(cleaned);\n    } catch(e) { return {}; }\n  }\n  return raw;\n}\n\nconst data = unwrap(pass1);\nconst speakers = data.speakers || [];\nconst prior = data.prior_state || {};\nconst delta = data.new_delta || {};\nconst isFirst = data.is_first_run !== false;\n\nconst speakerList = speakers.map(s => `- ${s.name} | ${s.role} | ${s.company}`).join('\\n') || 'No speakers identified.';\n\nconst content = `DELTA EVIDENCE DOCUMENT FOR P2V2C2 SCORING\n============================================\nThis document was produced by ECHO Pass 1 \u2014 The Delta Specialist.\nScore using the delta evidence below. Use prior scores as the FLOOR \u2014 scores can only hold or increase unless new evidence contradicts prior evidence.\n\nIDENTIFIED SPEAKERS\n-------------------\n${speakerList}\n\nPRIOR DEAL STATE (already confirmed \u2014 use as baseline)\n------------------------------------------------------\nStage: ${prior.stage || 'Unknown / First Run'}\nCAS: ${prior.cas || 'Unknown / First Run'}\nPrior Scores: Pain=${prior.pain_score||0} Power=${prior.power_score||0} Vision=${prior.vision_score||0} Value=${prior.value_score||0} Change=${prior.change_score||0} Control=${prior.control_score||0}\nPrior Evidence Summary: ${prior.summary || 'None \u2014 first run.'}\n\nNEW DELTA EVIDENCE (from current input only \u2014 what changed or was newly admitted)\n----------------------------------------------------------------------------------\nPAIN (new):\n${delta.pain || 'No new evidence \u2014 see prior state.'}\n\nPOWER (new):\n${delta.power || 'No new evidence \u2014 see prior state.'}\n\nVISION (new):\n${delta.vision || 'No new evidence \u2014 see prior state.'}\n\nVALUE (new):\n${delta.value || 'No new evidence \u2014 see prior state.'}\n\nCHANGE (new):\n${delta.change || 'No new evidence \u2014 see prior state.'}\n\nCONTROL (new):\n${delta.control || 'No new evidence \u2014 see prior state.'}\n\nNEW DAP DATES/MILESTONES MENTIONED:\n${delta.dap_dates_mentioned || 'None explicitly mentioned.'}`;\n\nreturn [{ json: { content, _pass1_raw: data } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        592,
        64
      ],
      "name": "Handoff 1 to 2",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.content }}",
        "options": {
          "systemMessage": "IDENTITY\nYou are ECHO Pass 2 \u2014 The Judge. You receive a structured delta evidence document from Pass 1. Your only job is to score all six P2V2C2 dimensions. You do not generate artifacts. You score and cite with precision.\n\nTHE RUBRIC\nScore | Pain | Power | Vision | Value | Change | Control\n0 | No knowledge of pain | No idea who is power | No idea of needs | Benefits unknown | No one committed | Buying process unknown\n1 | PC shared situation | Indication of PES | Begun to define needs | Believe situation causes pain | PC open to change | C described process\n2 | PC admitted pain | Champion agreed to take to PES | Mapped capabilities to needs | Defined cost of pain | PC confirmed PES will meet | Met with PES\n3 | PC indicated pain of PES | Met with PES | Agreed to proof criteria | Believe solution addresses pain | PES agreed need to change | Pain admitted & vision created for ES\n4 | PES admitted pain | PES agreed to DAP | ES agreed to vision | ES shared benefits with DM | ES chosen Clearwater to lead change | ES agreed to DAP\n5 | ES agreed pain great enough to change | DAP steps on schedule | ES painting vision to others | DM agreed to financial terms | ES convinced DM must change | DAP complete\n\nPC=Potential Champion, PES=Potential Executive Sponsor, C=Champion, ES=Executive Sponsor, DM=Decision Maker\n\nSCORING MANDATE \u2014 READ THIS BEFORE SCORING ANYTHING\n\nYou are not here to be conservative. You are here to be accurate.\n\nPAIN:\n- If the prospect uses a metaphor, analogy, or colorful language to describe a business risk, conflict of interest, or operational problem \u2014 that is an admission of pain. Score it.\n- \"The fox guarding the hen house\" = admitted conflict of interest = Pain Score 2 minimum.\n- If the prospect indicates the pain extends to leadership or the executive level, score 3.\n- Do not score 1 just because pain was \"soft\" \u2014 soft admissions still count.\n\nPOWER:\n- If ANY name is mentioned as a budget holder, decision maker, executive sponsor, or person who needs to approve \u2014 that is an indication of power. Score 1 minimum.\n- If the champion has agreed to introduce or facilitate access to that person \u2014 score 2.\n- A score of 0 means no name, no role, no hint of who holds authority. This is rare in any real conversation.\n\nVISION:\n- If the prospect has begun describing what they want the future to look like \u2014 even informally \u2014 score 1 minimum.\n- If they have mapped Clearwater's capabilities to their needs \u2014 score 2.\n\nVALUE:\n- If the prospect believes the current situation is costing them something (risk, compliance exposure, inefficiency) \u2014 score 1 minimum.\n- If they have defined a cost or quantified the pain \u2014 score 2.\n\nCHANGE:\n- If the prospect has expressed desire to align a decision with a specific timeline or event (e.g., MSP renewal) \u2014 that is a commitment to evaluate change. Score 2 minimum.\n- If the prospect has explicitly asked to \"spin the proposal again\" or restart a scoping conversation \u2014 that is an active commitment to move. Score 3.\n- Score 1 only if the prospect is passively open but has expressed no timeline or active intent.\n\nCONTROL:\n- If the prospect has described ANY part of the buying process (renewal dates, approval steps, budget cycles) \u2014 score 1 minimum.\n- If you have met with or been introduced to someone with purchasing authority \u2014 score 2.\n\nPRIOR SCORES AS FLOOR:\nPrior scores are provided in the evidence document. The current score for any dimension CANNOT be lower than the prior score unless the evidence document explicitly contradicts or retracts prior evidence.\nFLOOR ENFORCEMENT \u2014 CRITICAL RULE:\nIf the delta evidence document says \"No new evidence \u2014 see prior state\" for a dimension, you MUST use the prior score as the current score. Do not score 0 just because the current input added nothing new. The prior score represents confirmed evidence from a previous interaction. It does not expire.\n\nExample: Prior Pain = 3. Current delta says \"No new evidence.\" \u2192 Current Pain score = 3. Not 0. Not 1. 3.\n\nOnly lower a prior score if the delta evidence contains explicit contradiction or retraction of prior evidence.\n\nSCORING RULES\n1. Score using ONLY the evidence in the delta document. The evidence document is your ground truth.\n2. For each dimension, identify the HIGHEST rubric level directly supported by named evidence.\n3. You MUST cite: (a) the exact rubric row text, (b) the speaker name and role, (c) the verbatim quote.\n4. If evidence is ambiguous between two levels, do NOT default to the lower \u2014 assess which is better supported.\n5. The evidence_description format: \"[Dimension] ([score]/5) - [Intensity]. [One sentence using client's words, speaker-attributed.]\"\n   Intensity: 0=None, 1=Minimal, 2=Low, 3=Medium, 4=High, 5=Very Strong\n\nFORWARD-LOOKING STAGE LOGIC\nAfter scoring, determine the NEXT impending stage and CAS \u2014 not the current confirmed state.\n\nStage progression: Discover \u2192 Qualify \u2192 Prove \u2192 Negotiate \u2192 Close\nCAS progression within a stage: A \u2192 B \u2192 C\n\nRules:\n- If the delta evidence confirms the criteria for the CURRENT stage are substantially met \u2192 advance to the NEXT stage.\n- \"Substantially met\" means: champion identified, pain admitted, basic buying process described, and a clear next step agreed.\n- If Qualify criteria are met \u2192 output Stage: Prove, CAS: 3A or 3B as appropriate.\n- If uncertain, advance by half a step (e.g., stay in Qualify but advance CAS from 2A to 2B).\n\nOUTPUT FORMAT\nReturn ONLY the following JSON \u2014 no preamble, no markdown fences:\n{\n  \"next_stage\": \"\",\n  \"next_cas\": \"\",\n  \"scores\": {\n    \"pain\": {\n      \"score\": 0,\n      \"rubric_row_cited\": \"\",\n      \"speaker\": \"\",\n      \"verbatim_quote\": \"\",\n      \"evidence_description\": \"\"\n    },\n    \"power\": {\n      \"score\": 0,\n      \"rubric_row_cited\": \"\",\n      \"speaker\": \"\",\n      \"verbatim_quote\": \"\",\n      \"evidence_description\": \"\"\n    },\n    \"vision\": {\n      \"score\": 0,\n      \"rubric_row_cited\": \"\",\n      \"speaker\": \"\",\n      \"verbatim_quote\": \"\",\n      \"evidence_description\": \"\"\n    },\n    \"value\": {\n      \"score\": 0,\n      \"rubric_row_cited\": \"\",\n      \"speaker\": \"\",\n      \"verbatim_quote\": \"\",\n      \"evidence_description\": \"\"\n    },\n    \"change\": {\n      \"score\": 0,\n      \"rubric_row_cited\": \"\",\n      \"speaker\": \"\",\n      \"verbatim_quote\": \"\",\n      \"evidence_description\": \"\"\n    },\n    \"control\": {\n      \"score\": 0,\n      \"rubric_row_cited\": \"\",\n      \"speaker\": \"\",\n      \"verbatim_quote\": \"\",\n      \"evidence_description\": \"\"\n    }\n  }\n}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        800,
        64
      ],
      "name": "ECHO Pass 2 - Scoring",
      "alwaysOutputData": true,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        800,
        288
      ],
      "name": "GPT-4o Pass 2",
      "credentials": {
        "openAiApi": {
          "id": "fIeGh1UabUL1CBma",
          "name": "ECHO OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Handoff: Pass 1 + Pass 2 \u2192 Pass 3 Artifact Generation\nconst pass1 = $('ECHO Pass 1 - Evidence').item.json;\nconst pass2 = $('ECHO Pass 2 - Scoring').item.json;\nconst input = $('Input Classifier').item.json;\nconst dealContext = $('Merge Deal Context').item.json;\n\nfunction unwrap(node) {\n  const raw = node.output !== undefined ? node.output : node;\n  if (typeof raw === 'string') {\n    try {\n      const cleaned = raw.replace(/^```json\\s*/i, '').replace(/^```\\s*/i, '').replace(/```\\s*$/i, '').trim();\n      return JSON.parse(cleaned);\n    } catch(e) { return {}; }\n  }\n  return raw;\n}\n\nconst data1 = unwrap(pass1);\nconst data2 = unwrap(pass2);\nconst speakers = data1.speakers || [];\nconst prior = data1.prior_state || {};\nconst delta = data1.new_delta || {};\nconst scores = data2.scores || {};\nconst nextStage = data2.next_stage || '';\nconst nextCas = data2.next_cas || '';\n\nconst speakerList = speakers.map(s => `- ${s.name} | ${s.role} | ${s.company}`).join('\\n') || 'None identified.';\n\nfunction scoreBlock(dim) {\n  const s = scores[dim] || {};\n  return `${dim.toUpperCase()}: ${s.score !== undefined ? s.score : 0}/5\n  Rubric row cited: ${s.rubric_row_cited || 'none'}\n  Speaker: ${s.speaker || 'unknown'}\n  Quote: \"${s.verbatim_quote || ''}\"\n  Evidence description: ${s.evidence_description || ''}`;\n}\n\nconst priorScores = {\n  pain: prior.pain_score || 0,\n  power: prior.power_score || 0,\n  vision: prior.vision_score || 0,\n  value: prior.value_score || 0,\n  change: prior.change_score || 0,\n  control: prior.control_score || 0\n};\n\nconst currScores = {\n  pain: scores.pain?.score || 0,\n  power: scores.power?.score || 0,\n  vision: scores.vision?.score || 0,\n  value: scores.value?.score || 0,\n  change: scores.change?.score || 0,\n  control: scores.control?.score || 0\n};\n\nconst delta_line = Object.keys(priorScores).map(d => {\n  const diff = currScores[d] - priorScores[d];\n  const sign = diff > 0 ? '+' : '';\n  return `${d.charAt(0).toUpperCase()+d.slice(1)}: ${priorScores[d]}\u2192${currScores[d]} (${sign}${diff})`;\n}).join(' | ');\n\nconst content = `LIVING DEAL FILE \u2014 PASS 3 INPUT\n=================================\nDeal: ${input.deal_slug || 'unknown'}\nAccount: ${input.account_name || dealContext?.account_name || 'unknown'}\nInput Type: ${input.input_type || 'unknown'}\nAnchor Date: ${input.date || 'unknown'}\n\nNEXT STAGE (from Pass 2 \u2014 use this exactly in output):\nStage: ${nextStage}\nCAS: ${nextCas}\n\nIDENTIFIED SPEAKERS\n-------------------\n${speakerList}\n\nPRIOR DEAL STATE\n----------------\nStage: ${prior.stage || 'First Run'}\nCAS: ${prior.cas || 'First Run'}\nPrior Evidence Summary: ${prior.summary || 'None \u2014 first run.'}\n\nSCORE DELTA (prior \u2192 current)\n------------------------------\n${delta_line}\n\nNEW DELTA EVIDENCE (what was newly admitted in this input)\n----------------------------------------------------------\nPAIN: ${delta.pain || 'No new evidence.'}\nPOWER: ${delta.power || 'No new evidence.'}\nVISION: ${delta.vision || 'No new evidence.'}\nVALUE: ${delta.value || 'No new evidence.'}\nCHANGE: ${delta.change || 'No new evidence.'}\nCONTROL: ${delta.control || 'No new evidence.'}\nDAP Dates Mentioned: ${delta.dap_dates_mentioned || 'None.'}\n\nLOCKED P2V2C2 SCORES FROM PASS 2 \u2014 COPY THESE EXACTLY INTO OUTPUT\n-------------------------------------------------------------------\n${scoreBlock('pain')}\n\n${scoreBlock('power')}\n\n${scoreBlock('vision')}\n\n${scoreBlock('value')}\n\n${scoreBlock('change')}\n\n${scoreBlock('control')}\n\nRAW INPUT\n---------\n${(input.content || '').substring(0, 8000)}`;\n\nreturn [{ json: { content } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1008,
        64
      ],
      "name": "Handoff 2 to 3",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.content }}",
        "options": {
          "systemMessage": "IDENTITY\nYou are the Clearwater Dynamic Deal Architect. You perform a final strategic recalibration of a live deal using the \"Living Deal File\" (prior history) and the locked scores from Pass 2. You produce exactly 22 fields. You are a sophisticated strategist \u2014 not a corporate summarizer.\n\nKNOWLEDGE TOOLS\nUse the clearwater_knowledge_base tool to ensure all service descriptions use exact Clearwater terminology (MSS, MDR, IRM|Analysis, IRM|Pro, ClearAdvantage, vCISO, Technical Testing, Privacy & Compliance, BIA, ISO Maintenance, etc.).\n\nLOGIC ENGINE REQUIREMENTS\n\n1. FORWARD-LOOKING STAGE LOGIC \u2014 MANDATORY\nYour output MUST reflect the NEXT impending stage and CAS \u2014 the one Austin needs to execute, not the one just completed.\n- The stage and CAS provided in the input context are the NEXT stage already calculated by Pass 2. Use them exactly as given.\n- Do not revert to the current confirmed stage. The deal is always moving forward.\n\n2. DAP VELOCITY RULE \u2014 NON-NEGOTIABLE\n- \"Execute Contract\" MUST follow \"Finalize Redlines and Launch DocuSign\" by exactly 1-2 days.\n- The close_date in Phase 1 MUST match the \"Execute Contract\" date in the DAP timeline. They are the same event.\n- If they do not match, you have made an error. Fix it before outputting.\n\n3. NON-TRUNCATION RULE \u2014 ALL 14 MILESTONES\nEvery DAP timeline must contain all 14 milestones from Initial Discovery through Final Report Delivered. No \"...\" No skipping. No truncating.\n\n4. SCORE PASSTHROUGH \u2014 DO NOT RE-SCORE\nThe P2V2C2 scores in your output MUST be copied exactly from the locked Pass 2 scores in the input. You are not scoring. You are reporting.\n\n5. DELTA AWARENESS\nReference the score delta (change from prior scores) in the Internal Team Update. If a score moved, explain why. If nothing moved, note what is still unresolved.\n\n6. LIVING DEAL CONTEXT\nIf this is not the first run, the Internal Team Update must reference how the deal has evolved \u2014 what's new, what's confirmed, what's stalled.\n\n---\n\nREQUIRED OUTPUT \u2014 22 FIELDS\n\nPHASE 1: SALESFORCE DATA RECALIBRATION (Fields 1-4)\n\nField 1 \u2014 close_date: Must equal the \"Execute Contract\" date in the DAP timeline. One date, one event.\nField 2 \u2014 stage: The NEXT impending stage from Pass 2 (e.g., \"Prove\")\nField 3 \u2014 cas: The NEXT impending CAS from Pass 2 (e.g., \"3A: Prove - Determine Proof Criteria\")\nField 4 \u2014 forecast_category: [Omitted/Pipeline/Upside/Commit/Negotiate/Closed]\n\nPHASE 2: STRATEGIC BLOCKS (Fields 5-19)\n\nField 5 \u2014 salesforce_block_1_dap:\nMust contain ALL of the following in this order:\n  DAP Status: [Confirmed by client OR Internal Draft]\n  Timeline: (All 14 milestones, projected dates, Execute Contract 1-2 days after DocuSign)\n    [Date] - Initial Discovery [STATUS]\n    [Date] - Define Current State and Desired Future State [STATUS]\n    [Date] - Co-Create Session [STATUS]\n    [Date] - Present Draft Approach [STATUS]\n    [Date] - Present Updated Approach Based on Feedback [STATUS]\n    [Date] - Go / No Go Decision [STATUS]\n    [Date] - Submit for Budget Approval [STATUS]\n    [Date] - Send MSA/SOW [STATUS]\n    [Date] - [Client Name] Initial Review of MSA/SOW & Redlines [STATUS]\n    [Date] - Call to Review Redlines [STATUS]\n    [Date] - Finalize Redlines and Launch DocuSign [STATUS]\n    [Date] - Execute Contract [STATUS \u2014 MUST be 1-2 days after DocuSign line above]\n    [Date] - Initial Engagement Meeting / Project Start [STATUS]\n    [Date] - Final Report Delivered to [Client Name] [STATUS]\n  Current State:\n    ORGANIZATION: [text \u2014 no bullets]\n    ACTIVITIES: [text \u2014 no bullets]\n    TECHNOLOGY: [text \u2014 no bullets]\n  Future & Desired State (The \"Shining City on the Hill\"):\n    ORGANIZATION: [text \u2014 no bullets]\n    ACTIVITIES: [text \u2014 no bullets]\n    TECHNOLOGY: [text \u2014 no bullets]\n  Key Stakeholder Success Criteria:\n    TO THE BOARD: [text]\n    [STAKEHOLDER NAME/ROLE]: [text]\n\nField 6 \u2014 risks: Adversaries, \"vultures,\" timeline slippage, competitive threats. If the incumbent MSP is opportunistically pushing an early renewal to lock the client in before Clearwater can compete \u2014 call it what it is.\nField 7 \u2014 next_step: The single most critical immediate action to maintain deal control.\n\nFields 8-13 \u2014 Scores (copy exactly from Pass 2 locked scores):\n  Field 8  \u2014 pain_score\n  Field 9  \u2014 power_score\n  Field 10 \u2014 vision_score\n  Field 11 \u2014 value_score\n  Field 12 \u2014 change_score\n  Field 13 \u2014 control_score\n\nFields 14-19 \u2014 Evidence descriptions (copy exactly from Pass 2):\n  Field 14 \u2014 pain_evidence\n  Field 15 \u2014 power_evidence\n  Field 16 \u2014 vision_evidence\n  Field 17 \u2014 value_evidence\n  Field 18 \u2014 change_evidence\n  Field 19 \u2014 control_evidence\n\nPHASE 3: NARRATIVE ARTIFACTS (Fields 20-22)\n\nField 20 \u2014 call_summary and highlights:\n  SUMMARY: Concise factual recap \u2014 what happened, who participated, key strategic admissions.\n  HIGHLIGHTS: The 5-7 most important moments, each as a complete sentence. No one-word bullets.\n\nField 21 \u2014 action_items and internal_actions:\n  IMMEDIATE PROSPECT EXPECTATIONS: What the prospect expects to happen next and by when.\n  INTERNAL NEEDED OUTPUTS: Specific deliverables Austin and the team must produce (e.g., \"Draft proposal scoping MSS and compliance advisory,\" \"Identify executive introduction path to Adam\").\n\nField 22 \u2014 services_narrative:\n  List all Clearwater services mentioned or implied. Use exact service names. Include scope, timing, client sentiment, named colleagues, and behavioral observations that could improve deal path.\n\nTHE ANCHOR \u2014 INTERNAL TEAM UPDATE (embedded in internal_team_update field)\n\nTONE MANDATE: You are writing for a sophisticated audience who will see through generic corporate language. Be astute. Be specific. Treat the deal mechanics with serious, almost exaggerated reverence. If the incumbent MSP is maneuvering to lock the client into an early renewal before Clearwater can compete \u2014 that is a \"vulture maneuver\" and you will describe it as such with dry, professional wit. Do not write a standard summary. Write a strategic dispatch.\n\nStructure \u2014 follow exactly:\n  Opportunity Source: Where did this come from? Prior relationship, referral, former colleague's account, etc.\n  DAP Review: Is the deal on track, ahead, or slipping? One crisp paragraph.\n  Current/Future State Narrative: NO BULLETS. MANDATORY. Write a cohesive 2-3 paragraph story about the client's current environment, their plight, and their likely path to the \"Shining City on the Hill.\" Weave in deal history, context, and strategic color. This is a narrative, not a list.\n  P2V2C2 Strengths & Weaknesses: Where are we strong? Where are we exposed? Reference the delta from prior scores. Be specific about what moved and why.\n  Winning Strategy: The specific path to closing at the highest possible TCV. Name the services. Name the stakeholders. Name the timeline pressure points.\n  Leadership Help: Ask for something specific (intro, pricing exception, reference call) or state \"under control.\"\n\n---\n\nOUTPUT FORMAT\nReturn ONLY the following JSON \u2014 no preamble, no markdown fences:\n{\n  \"salesforce\": {\n    \"close_date\": \"\",\n    \"stage\": \"\",\n    \"cas\": \"\",\n    \"forecast_category\": \"\",\n    \"salesforce_block_1_dap\": \"\",\n    \"risks\": \"\",\n    \"next_step\": \"\",\n    \"pain_score\": 0,\n    \"pain_evidence\": \"\",\n    \"power_score\": 0,\n    \"power_evidence\": \"\",\n    \"vision_score\": 0,\n    \"vision_evidence\": \"\",\n    \"value_score\": 0,\n    \"value_evidence\": \"\",\n    \"change_score\": 0,\n    \"change_evidence\": \"\",\n    \"control_score\": 0,\n    \"control_evidence\": \"\"\n  },\n  \"narratives\": {\n    \"call_summary\": \"\",\n    \"highlights\": \"\",\n    \"action_items\": \"\",\n    \"p2v2c2_scoring\": \"\",\n    \"internal_actions\": \"\",\n    \"services_narrative\": \"\",\n    \"general_narrative\": \"\",\n    \"anecdotes\": \"\",\n    \"internal_team_update\": \"\"\n  }\n}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        1216,
        64
      ],
      "name": "ECHO Pass 3 - Artifacts",
      "alwaysOutputData": true,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "options": {
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1216,
        288
      ],
      "name": "GPT-4o Pass 3",
      "credentials": {
        "openAiApi": {
          "id": "fIeGh1UabUL1CBma",
          "name": "ECHO OpenAI API"
        }
      }
    }
  ],
  "connections": {
    "Gmail Trigger - Deal Inputs": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Triggers": {
      "main": [
        [
          {
            "node": "Input Classifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Input Classifier": {
      "main": [
        [
          {
            "node": "Load Deal Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Deal Memory": {
      "main": [
        [
          {
            "node": "Validate Deal Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Deal Memory": {
      "main": [
        [
          {
            "node": "Check Deal Exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format for PostgreSQL": {
      "main": [
        [
          {
            "node": "Open Review Portal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Review (Editing Portal)": {
      "main": [
        [
          {
            "node": "Merge Edited Artifacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Edited Artifacts": {
      "main": [
        [
          {
            "node": "Check if New Deal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if New Deal": {
      "main": [
        [
          {
            "node": "Insert New Deal",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Existing Deal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert New Deal": {
      "main": [
        [
          {
            "node": "Save Artifacts",
            "type": "main",
            "index": 0
          },
          {
            "node": "Save Artifact Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Existing Deal": {
      "main": [
        [
          {
            "node": "Save Artifacts",
            "type": "main",
            "index": 0
          },
          {
            "node": "Save Artifact Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Artifacts": {
      "main": [
        [
          {
            "node": "Save P2V2C2 Evidence",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save P2V2C2 Evidence": {
      "main": [
        [
          {
            "node": "Save History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save History": {
      "main": [
        [
          {
            "node": "Gmail - Send Artifacts Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Deal Exists": {
      "main": [
        [
          {
            "node": "Merge Deal Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Opportunity",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New Opportunity": {
      "main": [
        [
          {
            "node": "Merge Deal Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Open Review Portal": {
      "main": [
        [
          {
            "node": "Wait for Review (Editing Portal)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Embeddings": {
      "ai_embedding": [
        [
          {
            "node": "ECHO Knowledge Base (PGVector)",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "ECHO Knowledge Base (PGVector)": {
      "ai_tool": [
        [
          {
            "node": "ECHO Pass 3 - Artifacts",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Merge Deal Context": {
      "main": [
        [
          {
            "node": "ECHO Pass 1 - Evidence",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ECHO Pass 1 - Evidence": {
      "main": [
        [
          {
            "node": "Handoff 1 to 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GPT-4o Pass 1": {
      "ai_languageModel": [
        [
          {
            "node": "ECHO Pass 1 - Evidence",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Handoff 1 to 2": {
      "main": [
        [
          {
            "node": "ECHO Pass 2 - Scoring",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ECHO Pass 2 - Scoring": {
      "main": [
        [
          {
            "node": "Handoff 2 to 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GPT-4o Pass 2": {
      "ai_languageModel": [
        [
          {
            "node": "ECHO Pass 2 - Scoring",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Handoff 2 to 3": {
      "main": [
        [
          {
            "node": "ECHO Pass 3 - Artifacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ECHO Pass 3 - Artifacts": {
      "main": [
        [
          {
            "node": "Format for PostgreSQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GPT-4o Pass 3": {
      "ai_languageModel": [
        [
          {
            "node": "ECHO Pass 3 - Artifacts",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "binaryMode": "separate"
  },
  "tags": [],
  "active": true,
  "isArchived": false
}