{
  "id": "RlnZGOaKU4ee7D6M",
  "name": "ECHOv4 - PostgreSQL_TESTING",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyX",
              "value": 1,
              "unit": "minutes"
            }
          ]
        },
        "simple": false,
        "filters": {
          "sender": "austin.holland@clearwatersecurity.com"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1.3,
      "position": [
        -896,
        256
      ],
      "name": "Gmail Trigger - Deal Inputs",
      "alwaysOutputData": false,
      "executeOnce": false,
      "credentials": {
        "gmailOAuth2": {
          "id": "KcxcROH9oa3L7IUB",
          "name": "Gmail ECHO"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Classify input type and extract content\nconst items = $input.all();\nconst results = [];\n\n// Helper: Normalize account name to slug format\nfunction normalizeToSlug(text) {\n  if (!text) return null;\n  return text\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')  // Replace non-alphanumeric with dashes\n    .replace(/^-+|-+$/g, '')      // Trim leading/trailing dashes\n    .replace(/-+/g, '-');          // Collapse multiple dashes\n}\n\nfor (const item of items) {\n  // Check if input is from webhook (MCP) or Gmail\n  const isWebhook = item.json.body !== undefined;\n  \n  let content, subject, input_type, deal_slug, salesforce_opportunity_id, date, source_filename;\n  let opportunity_name, account_name, close_date, trigger_type;\n  \n  if (isWebhook) {\n    // MCP/Webhook input - convert camelCase to snake_case\n    const body = item.json.body;\n    // Generate content from webhook fields if not provided\n    if (body.content) {\n      content = body.content;\n    } else {\n      // Build descriptive content from available fields\n      const parts = [];\n      if (trigger_type && trigger_type !== 'deal_intake') {\n        parts.push(`${trigger_type}`);\n      } else {\n        parts.push('New deal opportunity');\n      }\n      \n      if (opportunity_name) {\n        parts.push(`\"${opportunity_name}\"`);\n      }\n      \n      if (account_name) {\n        parts.push(`at ${account_name}`);\n      }\n      \n      if (close_date) {\n        parts.push(`(expected close: ${close_date})`);\n      }\n      \n      content = parts.join(' ') + '. This is initial deal intake with minimal information.';\n    }\n    input_type = body.input_type || body.inputType || 'call_transcript';\n    opportunity_name = body.opportunity_name || body.opportunityName || null;\n    account_name = body.account_name || body.accountName || null;\n    close_date = body.close_date || body.closeDate || null;\n    trigger_type = body.trigger_type || body.triggerType || 'deal_intake';\n    salesforce_opportunity_id = body.salesforce_opportunity_id || body.salesforceOpportunityId || null;\n    date = body.date || new Date().toISOString().split('T')[0];\n    source_filename = body.source_filename || body.sourceFilename || 'mcp-input';\n    \n    // Slug generation logic:\n    // 1. Use provided slug if exists\n    // 2. Normalize account_name if provided\n    // 3. Fall back to date-based slug\n    if (body.deal_slug || body.dealSlug) {\n      deal_slug = body.deal_slug || body.dealSlug;\n    } else if (account_name) {\n      const accountSlug = normalizeToSlug(account_name);\n      deal_slug = `${accountSlug}-${date}`;\n    } else {\n      deal_slug = `deal-${date}`;\n    }\n    \n  } else {\n    // Gmail input\n    subject = item.json.subject || '';\n    const text = item.json.text || item.json.textPlain || '';\n    content = text;\n    \n    // Check for X-ECHO-Deal-Slug header first (most reliable)\n    const headers = item.json.headers || {};\n    const echoSlugHeader = headers['x-echo-deal-slug'] || headers['X-ECHO-Deal-Slug'] || headers['X-Echo-Deal-Slug'];\n    \n    if (echoSlugHeader) {\n      deal_slug = echoSlugHeader;\n    } else {\n      // Strip email prefixes (Re:, Fwd:, FW:, etc.) then extract account name\n      const cleanSubject = subject.replace(/^(Re:|Fwd:|FW:|RE:|FWD:)\\s*/gi, '').trim();\n      const subjectMatch = cleanSubject.match(/^([^-]+)/);\n      if (subjectMatch) {\n        const extractedAccount = subjectMatch[1].trim();\n        account_name = extractedAccount;\n        deal_slug = `${normalizeToSlug(extractedAccount)}-${new Date().toISOString().split('T')[0]}`;\n      } else {\n        deal_slug = `deal-${new Date().toISOString().split('T')[0]}`;\n      }\n    }\n    \n    // Determine input type\n    input_type = 'email';\n    if (subject.toLowerCase().includes('transcript')) {\n      input_type = 'call_transcript';\n    } else if (subject.toLowerCase().includes('notes')) {\n      input_type = 'call_notes';\n    }\n    \n    salesforce_opportunity_id = null;\n    date = new Date().toISOString().split('T')[0];\n    source_filename = `email-${item.json.id || 'unknown'}`;\n    opportunity_name = null;\n    close_date = null;\n    trigger_type = 'email_trigger';\n  }\n  \n  results.push({\n    json: {\n      content: content,\n      subject: subject,\n      input_type: input_type,\n      deal_slug: deal_slug,\n      salesforce_opportunity_id: salesforce_opportunity_id,\n      date: date,\n      source_filename: source_filename,\n      opportunity_name: opportunity_name,\n      account_name: account_name,\n      close_date: close_date,\n      trigger_type: trigger_type\n    }\n  });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        160
      ],
      "name": "Input Classifier"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM deals \nWHERE salesforce_opportunity_id = '{{ $json.salesforce_opportunity_id }}'\n   OR deal_slug = '{{ $json.deal_slug }}'\n   OR (account_name IS NOT NULL \n       AND account_name ILIKE '{{ $json.account_name }}%')\nORDER BY \n  CASE \n    WHEN deal_slug = '{{ $json.deal_slug }}' THEN 1\n    WHEN salesforce_opportunity_id = '{{ $json.salesforce_opportunity_id }}' THEN 2\n    ELSE 3\n  END,\n  updated_at DESC\nLIMIT 1",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -464,
        160
      ],
      "name": "Load Deal Memory",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      },
      "continueOnFail": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\n// Get input data using correct n8n syntax\nconst inputData = $('Input Classifier').item.json;\n\n// Check what we got from Load Deal Memory\nconst dealData = items?.[0]?.json;\nconst idValue = dealData?.id;\n\n// Check for valid deal - id must be a positive number\nconst hasValidDeal = typeof idValue === 'number' && idValue > 0;\n\nif (!hasValidDeal) {\n  // No valid deal\n  return [{ \n    json: { \n      _noDealsFound: true,\n      _contextSource: 'new_opportunity',\n      deal_slug: inputData.deal_slug,\n      opportunity_name: inputData.opportunity_name,\n      account_name: inputData.account_name,\n      close_date: inputData.close_date,\n      salesforce_opportunity_id: inputData.salesforce_opportunity_id,\n      trigger_type: inputData.trigger_type,\n      content: inputData.content,\n      input_type: inputData.input_type\n    }\n  }];\n}\n\n// Deal found\nreturn [{ \n  json: {\n    ...dealData,\n    _noDealsFound: false,\n    _contextSource: 'existing_deal',\n    content: inputData.content\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        32
      ],
      "name": "Validate Deal Memory",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Format outputs from both ECHO agents for PostgreSQL and review portal\nconst agent1 = $('ECHO Pass 3 - Artifacts').item.json;\nconst agent2 = $('ECHO Pass 3 - Artifacts').item.json;\nconst input = $('Input Classifier').item.json;\nconst dealContext = $('Merge Deal Context').item.json;\n\nif (!agent1 || !input) {\n  throw new Error('Missing required data from ECHO Intelligence Engine or Input Classifier');\n}\n\nfunction esc(val) {\n  if (val === null || val === undefined || val === '') return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction escStr(val) {\n  if (val === null || val === undefined) return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction escNum(val) {\n  const n = Number(val);\n  return isNaN(n) ? '0' : String(n);\n}\n\nfunction unwrap(node) {\n  const raw = node.output !== undefined ? node.output : node;\n  if (typeof raw === 'string') {\n    try {\n      const cleaned = raw.replace(/^```json\\s*/i, '').replace(/^```\\s*/i, '').replace(/```\\s*$/i, '').trim();\n      return JSON.parse(cleaned);\n    } catch(e) { return {}; }\n  }\n  return raw;\n}\n\nconst data1 = unwrap(agent1);\nconst sf = data1.salesforce || {};\n\nconst data2 = unwrap(agent2);\nconst narr = data2.narratives || {};\n\nfunction extractStageCode(casStr) {\n  if (!casStr) return '1A';\n  const match = casStr.match(/^([1-5][AB])/i);\n  if (match) return match[1].toUpperCase();\n  const s = casStr.toLowerCase();\n  if (s.includes('close') || s.includes('won') || s.includes('lost')) return '5A';\n  if (s.includes('negot') || s.includes('contract') || s.includes('msa') || s.includes('sow')) return '4A';\n  if (s.includes('prov') || s.includes('valid') || s.includes('proposal') || s.includes('demo')) return '3A';\n  if (s.includes('qualif') || s.includes('engaged') || s.includes('discover')) return '2A';\n  return '1A';\n}\n\nconst deal_slug = input.deal_slug || '';\nconst salesforce_opportunity_id = dealContext?.salesforce_opportunity_id || input.salesforce_opportunity_id || null;\nconst opportunity_name = input.opportunity_name || dealContext?.opportunity_name || '';\nconst account_name = input.account_name || dealContext?.account_name || '';\n\nconst close_date = sf.close_date || null;\nconst stage = sf.stage || '';\nconst cas = sf.cas || '';\nconst forecast_category = sf.forecast_category || '';\nconst salesforce_block_1_dap = sf.salesforce_block_1_dap || '';\nconst risks = sf.risks || '';\nconst next_step = sf.next_step || '';\n\nconst pain_score = Number(sf.pain_score) || 0;\nconst pain_evidence = sf.pain_evidence || '';\nconst power_score = Number(sf.power_score) || 0;\nconst power_evidence = sf.power_evidence || '';\nconst vision_score = Number(sf.vision_score) || 0;\nconst vision_evidence = sf.vision_evidence || '';\nconst value_score = Number(sf.value_score) || 0;\nconst value_evidence = sf.value_evidence || '';\nconst change_score = Number(sf.change_score) || 0;\nconst change_evidence = sf.change_evidence || '';\nconst control_score = Number(sf.control_score) || 0;\nconst control_evidence = sf.control_evidence || '';\nconst p2v2c2_total = pain_score + power_score + vision_score + value_score + change_score + control_score;\n\nconst call_summary = narr.call_summary || '';\nconst highlights = narr.highlights || '';\nconst action_items = narr.action_items || '';\nconst p2v2c2_scoring = narr.p2v2c2_scoring || '';\nconst internal_actions = narr.internal_actions || '';\nconst services_narrative = narr.services_narrative || '';\nconst general_narrative = narr.general_narrative || '';\nconst anecdotes = narr.anecdotes || '';\nconst internal_team_update = narr.internal_team_update || '';\n\nconst stage_code = extractStageCode(cas);\nconst cas_confidence = 'medium';\nconst event_type = input.input_type || '';\nconst event_date = input.date || new Date().toISOString().split('T')[0];\nconst summary_str = `Processed ${input.input_type} - CAS: ${cas || 'N/A'}`;\nconst link_or_ref = input.source_filename || '';\nconst raw_content = (input.content || '').substring(0, 5000);\n\nconst insertDealSQL = `INSERT INTO deals (\n  deal_slug, salesforce_opportunity_id, outputs_version,\n  opportunity_name, account_name, stage, cas_current, cas_next, cas_confidence,\n  pain_score, power_score, vision_score, value_score, change_score, control_score\n) VALUES (\n  ${esc(deal_slug)}, ${esc(salesforce_opportunity_id)}, 'v4',\n  ${escStr(opportunity_name)}, ${escStr(account_name)}, ${escStr(stage_code)},\n  ${escStr(cas)}, ${escStr('')}, ${escStr(cas_confidence)},\n  ${escNum(pain_score)}, ${escNum(power_score)}, ${escNum(vision_score)},\n  ${escNum(value_score)}, ${escNum(change_score)}, ${escNum(control_score)}\n)\nON CONFLICT (deal_slug) DO UPDATE SET\n  salesforce_opportunity_id = EXCLUDED.salesforce_opportunity_id,\n  outputs_version = EXCLUDED.outputs_version,\n  opportunity_name = EXCLUDED.opportunity_name,\n  account_name = EXCLUDED.account_name,\n  stage = EXCLUDED.stage,\n  cas_current = EXCLUDED.cas_current,\n  cas_confidence = EXCLUDED.cas_confidence,\n  pain_score = EXCLUDED.pain_score,\n  power_score = EXCLUDED.power_score,\n  vision_score = EXCLUDED.vision_score,\n  value_score = EXCLUDED.value_score,\n  change_score = EXCLUDED.change_score,\n  control_score = EXCLUDED.control_score,\n  updated_at = CURRENT_TIMESTAMP\nRETURNING id`;\n\nconst updateDealSQL = `UPDATE deals SET\n  salesforce_opportunity_id = ${esc(salesforce_opportunity_id)},\n  outputs_version = 'v4',\n  opportunity_name = ${escStr(opportunity_name)},\n  account_name = ${escStr(account_name)},\n  stage = ${escStr(stage_code)},\n  cas_current = ${escStr(cas)},\n  cas_confidence = ${escStr(cas_confidence)},\n  close_date = ${close_date ? escStr(close_date) : 'NULL'},\n  updated_at = CURRENT_TIMESTAMP\nWHERE deal_slug = ${esc(deal_slug)}\nRETURNING *`;\n\nconst saveArtifactsSQL = `INSERT INTO artifacts (\n  deal_id,\n  salesforce_block_1_dap,\n  salesforce_pain_description, salesforce_power_description,\n  salesforce_vision_description, salesforce_value_description,\n  salesforce_change_description, salesforce_control_description,\n  approved\n) VALUES (\n  (SELECT id FROM deals WHERE deal_slug = ${esc(deal_slug)}),\n  ${esc(salesforce_block_1_dap)},\n  ${esc(pain_evidence)}, ${esc(power_evidence)},\n  ${esc(vision_evidence)}, ${esc(value_evidence)},\n  ${esc(change_evidence)}, ${esc(control_evidence)},\n  false\n)\nRETURNING id`;\n\nconst saveEvidenceSQL = `INSERT INTO p2v2c2_evidence (\n  deal_id, pain_score, pain_evidence, power_score, power_evidence,\n  vision_score, vision_evidence, value_score, value_evidence,\n  change_score, change_evidence, control_score, control_evidence, p2v2c2_total\n) VALUES (\n  (SELECT id FROM deals WHERE deal_slug = ${esc(deal_slug)}),\n  ${escNum(pain_score)}, ${esc(pain_evidence)},\n  ${escNum(power_score)}, ${esc(power_evidence)},\n  ${escNum(vision_score)}, ${esc(vision_evidence)},\n  ${escNum(value_score)}, ${esc(value_evidence)},\n  ${escNum(change_score)}, ${esc(change_evidence)},\n  ${escNum(control_score)}, ${esc(control_evidence)},\n  ${escNum(p2v2c2_total)}\n)\nRETURNING id`;\n\nconst saveHistorySQL = `INSERT INTO deal_history (\n  deal_id, event_type, event_source, event_date, summary,\n  link_or_ref, raw_content, cas_at_time, p2v2c2_total_at_time\n) VALUES (\n  (SELECT id FROM deals WHERE deal_slug = ${esc(deal_slug)}),\n  ${escStr(event_type)}, ${esc('')}, ${escStr(event_date)}::date,\n  ${escStr(summary_str)}, ${esc(link_or_ref)}, ${escStr(raw_content)},\n  ${escStr(cas)}, ${escNum(p2v2c2_total)}\n)\nRETURNING id`;\n\nconst deal = {\n  deal_slug, salesforce_opportunity_id, outputs_version: 'v4',\n  opportunity_name, account_name, stage: stage_code,\n  cas_current: cas, cas_next: '', cas_confidence, close_date,\n  pain_score, power_score, vision_score, value_score, change_score, control_score\n};\n\nreturn [{\n  json: {\n    deal,\n    _contextSource: dealContext?._contextSource || 'unknown',\n    insertDealSQL, updateDealSQL, saveArtifactsSQL, saveEvidenceSQL, saveHistorySQL,\n    close_date, stage, cas, forecast_category,\n    salesforce_block_1_dap, risks, next_step,\n    pain_score, pain_evidence,\n    power_score, power_evidence,\n    vision_score, vision_evidence,\n    value_score, value_evidence,\n    change_score, change_evidence,\n    control_score, control_evidence,\n    p2v2c2_total,\n    call_summary, highlights, action_items, p2v2c2_scoring,\n    internal_actions, services_narrative, general_narrative,\n    anecdotes, internal_team_update\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1424,
        64
      ],
      "name": "Format for PostgreSQL"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://host.docker.internal:5679/receive",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"execution_id\": \"{{ $execution.id }}\"\n}",
        "options": {
          "timeout": 5000,
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        800,
        280
      ],
      "name": "Open Review Portal"
    },
    {
      "parameters": {
        "resume": "form",
        "formTitle": "Review & Edit Deal Artifacts",
        "formDescription": "Review and edit AI-generated artifacts before saving. Leave any field blank to keep the AI original. Check the Review Required email for the pre-filled content to copy in.",
        "formFields": {
          "values": [
            {
              "fieldLabel": "close_date",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.close_date }}"
            },
            {
              "fieldLabel": "stage",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.stage }}"
            },
            {
              "fieldLabel": "cas",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.cas }}"
            },
            {
              "fieldLabel": "forecast_category",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.forecast_category }}"
            },
            {
              "fieldLabel": "salesforce_block_1_dap",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.salesforce_block_1_dap }}"
            },
            {
              "fieldLabel": "risks",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.risks }}"
            },
            {
              "fieldLabel": "next_step",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.next_step }}"
            },
            {
              "fieldLabel": "pain_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.pain_score }}"
            },
            {
              "fieldLabel": "pain_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.pain_evidence }}"
            },
            {
              "fieldLabel": "power_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.power_score }}"
            },
            {
              "fieldLabel": "power_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.power_evidence }}"
            },
            {
              "fieldLabel": "vision_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.vision_score }}"
            },
            {
              "fieldLabel": "vision_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.vision_evidence }}"
            },
            {
              "fieldLabel": "value_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.value_score }}"
            },
            {
              "fieldLabel": "value_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.value_evidence }}"
            },
            {
              "fieldLabel": "change_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.change_score }}"
            },
            {
              "fieldLabel": "change_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.change_evidence }}"
            },
            {
              "fieldLabel": "control_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.control_score }}"
            },
            {
              "fieldLabel": "control_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.control_evidence }}"
            },
            {
              "fieldLabel": "call_summary",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.call_summary }}"
            },
            {
              "fieldLabel": "highlights",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.highlights }}"
            },
            {
              "fieldLabel": "action_items",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.action_items }}"
            },
            {
              "fieldLabel": "p2v2c2_scoring",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.p2v2c2_scoring }}"
            },
            {
              "fieldLabel": "internal_actions",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.internal_actions }}"
            },
            {
              "fieldLabel": "services_narrative",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.services_narrative }}"
            },
            {
              "fieldLabel": "general_narrative",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.general_narrative }}"
            },
            {
              "fieldLabel": "anecdotes",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.anecdotes }}"
            },
            {
              "fieldLabel": "internal_team_update",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.internal_team_update }}"
            }
          ]
        },
        "responseMode": "onReceived",
        "options": {
          "responseText": "Artifacts saved. Check your email for the final output."
        }
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        1000,
        64
      ],
      "name": "Wait for Review (Editing Portal)",
      "webhookId": "echo-artifact-review"
    },
    {
      "parameters": {
        "jsCode": "// Merge original AI outputs with edits from the review form\nconst orig = $('Format for PostgreSQL').item.json;\nconst form = $input.item.json;\n\nfunction esc(val) {\n  if (val === null || val === undefined || val === '') return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction escStr(val) {\n  if (val === null || val === undefined) return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction escNum(val) {\n  const n = Number(val);\n  return isNaN(n) ? '0' : String(n);\n}\n\nfunction edited(formVal, origVal) {\n  const f = (formVal || '').trim();\n  return f.length > 0 ? f : (origVal || '');\n}\nfunction editedNum(formVal, origVal) {\n  const f = String(formVal || '').trim();\n  const n = Number(f);\n  return (!isNaN(n) && f.length > 0) ? n : origVal;\n}\n\n// Salesforce standalone\nconst close_date = edited(form['close_date'], orig.close_date);\nconst stage = edited(form['stage'], orig.stage);\nconst cas = edited(form['cas'], orig.cas);\nconst forecast_category = edited(form['forecast_category'], orig.forecast_category);\nconst salesforce_block_1_dap = edited(form['salesforce_block_1_dap'], orig.salesforce_block_1_dap);\nconst risks = edited(form['risks'], orig.risks);\nconst next_step = edited(form['next_step'], orig.next_step);\n\n// P2V2C2\nconst pain_score = editedNum(form['pain_score'], orig.pain_score);\nconst pain_evidence = edited(form['pain_evidence'], orig.pain_evidence);\nconst power_score = editedNum(form['power_score'], orig.power_score);\nconst power_evidence = edited(form['power_evidence'], orig.power_evidence);\nconst vision_score = editedNum(form['vision_score'], orig.vision_score);\nconst vision_evidence = edited(form['vision_evidence'], orig.vision_evidence);\nconst value_score = editedNum(form['value_score'], orig.value_score);\nconst value_evidence = edited(form['value_evidence'], orig.value_evidence);\nconst change_score = editedNum(form['change_score'], orig.change_score);\nconst change_evidence = edited(form['change_evidence'], orig.change_evidence);\nconst control_score = editedNum(form['control_score'], orig.control_score);\nconst control_evidence = edited(form['control_evidence'], orig.control_evidence);\nconst p2v2c2_total = pain_score + power_score + vision_score + value_score + change_score + control_score;\n\n// Narratives\nconst call_summary = edited(form['call_summary'], orig.call_summary);\nconst highlights = edited(form['highlights'], orig.highlights);\nconst action_items = edited(form['action_items'], orig.action_items);\nconst p2v2c2_scoring = edited(form['p2v2c2_scoring'], orig.p2v2c2_scoring);\nconst internal_actions = edited(form['internal_actions'], orig.internal_actions);\nconst services_narrative = edited(form['services_narrative'], orig.services_narrative);\nconst general_narrative = edited(form['general_narrative'], orig.general_narrative);\nconst anecdotes = edited(form['anecdotes'], orig.anecdotes);\nconst internal_team_update = edited(form['internal_team_update'], orig.internal_team_update);\n\nconst deal_slug = orig.deal.deal_slug;\n\nreturn [{\n  json: {\n    deal: orig.deal,\n    close_date, stage, cas, forecast_category,\n    salesforce_block_1_dap, risks, next_step,\n    pain_score, pain_evidence,\n    power_score, power_evidence,\n    vision_score, vision_evidence,\n    value_score, value_evidence,\n    change_score, change_evidence,\n    control_score, control_evidence,\n    p2v2c2_total,\n    call_summary, highlights, action_items, p2v2c2_scoring,\n    internal_actions, services_narrative, general_narrative,\n    anecdotes, internal_team_update\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        64
      ],
      "name": "Merge Edited Artifacts"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "check-new-opp-id",
              "leftValue": "={{ $json._contextSource?.toLowerCase().trim() }}",
              "operator": {
                "type": "string",
                "operation": "contains",
                "singleValue": "new"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1120,
        64
      ],
      "name": "Check if New Deal"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.insertDealSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1280,
        -32
      ],
      "name": "Insert New Deal",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.updateDealSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1280,
        160
      ],
      "name": "Update Existing Deal",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Merge Edited Artifacts').item.json.saveArtifactsSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1440,
        64
      ],
      "name": "Save Artifacts",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Merge Edited Artifacts').item.json.saveFeedbackSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1440,
        208
      ],
      "name": "Save Artifact Feedback",
      "continueOnFail": true,
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Format for PostgreSQL').item.json.saveEvidenceSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1584,
        64
      ],
      "name": "Save P2V2C2 Evidence",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Format for PostgreSQL').item.json.saveHistorySQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1728,
        64
      ],
      "name": "Save History",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge both trigger sources\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -752,
        160
      ],
      "name": "Merge Triggers"
    },
    {
      "parameters": {
        "sendTo": "austin.holland@clearwatersecurity.com",
        "subject": "Deal Path Artifacts Notification",
        "message": "=<h2>Deal Path Artifacts \u2014 Final (Reviewed)</h2>\n\n<p><strong>Deal:</strong> {{ $('Merge Edited Artifacts').item.json.deal.deal_slug }}</p>\n<p><strong>Opportunity:</strong> {{ $('Merge Edited Artifacts').item.json.deal.opportunity_name }}</p>\n<p><strong>Date:</strong> {{ $('Input Classifier').item.json.date }}</p>\n<p><strong>Input Type:</strong> {{ $('Input Classifier').item.json.input_type }}</p>\n\n<h3>CAS Stage</h3>\n<p><strong>Current:</strong> {{ $('Merge Edited Artifacts').item.json.deal.cas_current }}</p>\n<p><strong>Next:</strong> {{ $('Merge Edited Artifacts').item.json.deal.cas_next }}</p>\n\n<hr>\n\n<h3>Artifacts (Reviewed &amp; Approved)</h3>\n\n<h4>Client Follow-Up Email</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">{{ $('Merge Edited Artifacts').item.json.client_follow_up_email }}</pre>\n\n<h4>Salesforce DAP Block</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">{{ $('Merge Edited Artifacts').item.json.salesforce_block_1_dap }}</pre>\n\n<h4>Salesforce P2V2C2</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">Pain ({{ $('Merge Edited Artifacts').item.json.pain_score }}/5): {{ $('Merge Edited Artifacts').item.json.pain_evidence }}\n\nPower ({{ $('Merge Edited Artifacts').item.json.power_score }}/5): {{ $('Merge Edited Artifacts').item.json.power_evidence }}\n\nVision ({{ $('Merge Edited Artifacts').item.json.vision_score }}/5): {{ $('Merge Edited Artifacts').item.json.vision_evidence }}\n\nValue ({{ $('Merge Edited Artifacts').item.json.value_score }}/5): {{ $('Merge Edited Artifacts').item.json.value_evidence }}\n\nChange ({{ $('Merge Edited Artifacts').item.json.change_score }}/5): {{ $('Merge Edited Artifacts').item.json.change_evidence }}\n\nControl ({{ $('Merge Edited Artifacts').item.json.control_score }}/5): {{ $('Merge Edited Artifacts').item.json.control_evidence }}\n\nTotal: {{ $('Merge Edited Artifacts').item.json.p2v2c2_total }}/30</pre>\n\n<h4>Executive Recap</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">{{ $('Merge Edited Artifacts').item.json.exec_recap_forwardable }}</pre>\n\n<h4>Internal Message - Pricing</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">{{ $('Merge Edited Artifacts').item.json.internal_message_pricing }}</pre>",
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        1872,
        160
      ],
      "name": "Gmail - Send Artifacts Email",
      "webhookId": "d41f4808-1611-40bf-b933-cb7ec9b596ad",
      "credentials": {
        "gmailOAuth2": {
          "id": "KcxcROH9oa3L7IUB",
          "name": "Gmail ECHO"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "check-deal-found",
              "leftValue": "={{ $('Load Deal Memory').item.json.id }}",
              "operator": {
                "type": "string",
                "operation": "exists"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -288,
        240
      ],
      "name": "Check Deal Exists"
    },
    {
      "parameters": {
        "jsCode": "// Initialize a new opportunity when deal doesn't exist\nconst input = $('Input Classifier').item.json;\n\nconst newDeal = {\n  json: {\n    kind: 'deal_record',\n    deal_slug: input.deal_slug,\n    salesforce_opportunity_id: null,\n    _contextSource: 'new_opportunity',\n    outputs_version: 'v2',\n    content: input.content || `New deal opportunity: ${input.opportunity_name || 'unnamed'} at ${input.account_name || 'unknown account'}. Expected close: ${input.close_date || 'TBD'}`,\n    input_type: input.input_type || 'deal_intake',\n    \n    updated_at: new Date().toISOString(),\n    \n    opportunity_name: '',\n    account_name: '',\n    cas_current: '1A: Discovery - Initial conversation',\n    cas_next: '1B: Discovery - Problem validation',\n    cas_confidence: 'low',\n    \n    pain_score: 0,\n    power_score: 0,\n    vision_score: 0,\n    value_score: 0,\n    change_score: 0,\n    control_score: 0\n  }\n};\n\nreturn [newDeal];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        224
      ],
      "name": "Create New Opportunity",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst dealContext = items[0];\nconst contextSource = dealContext.json._contextSource || 'unknown';\n\nconsole.log('Merge Deal Context - contextSource:', contextSource);\n\nreturn [{\n  json: {\n    ...dealContext.json,\n    _contextSource: contextSource\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        80
      ],
      "name": "Merge Deal Context"
    },
    {
      "parameters": {
        "model": "text-embedding-3-small",
        "options": {
          "baseURL": "https://api.openai.com/v1"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1,
      "position": [
        240,
        560
      ],
      "name": "OpenAI Embeddings",
      "credentials": {
        "openAiApi": {
          "id": "fIeGh1UabUL1CBma",
          "name": "ECHO OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "mode": "retrieve-as-tool",
        "toolName": "clearwater_knowledge_base",
        "toolDescription": "Search Clearwater's CPS methodology (P2V2C2 scoring rubric 0-5 definitions, DAP structure, sales stages Discover/Qualify/Prove/Negotiate/Close, Champion/PES/ES/DM role definitions) and Clearwater's full service catalog (MSS, MDR, Risk Analysis, IRM|Pro, ClearAdvantage, vCISO, Privacy & Compliance, Technical Testing, etc.). Use this tool to look up scoring criteria, service terminology, and sales process definitions.",
        "tableName": "n8n_vectors",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePGVector",
      "typeVersion": 1.3,
      "position": [
        240,
        480
      ],
      "name": "ECHO Knowledge Base (PGVector)",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.content }}",
        "options": {
          "systemMessage": "IDENTITY\nYou are ECHO Pass 1 \u2014 Evidence Extractor. Your only job is to read a raw sales call transcript or email and produce a structured, speaker-attributed evidence document. You do not score anything. You do not interpret anything. You extract and organize.\n\nSTEP 1 \u2014 IDENTIFY SPEAKERS\nBefore extracting evidence, identify every speaker in the transcript.\n\nRules:\n- Look for explicit name mentions (\"Hi, I'm Sarah\", \"Austin here\", \"Dr. Jones said\")\n- Look for role signals (\"our CEO\", \"our IT director\", \"the champion we've been working with\")\n- Look for first-person context clues (\"we have 200 employees\", \"I report to the board\")\n- Austin Holland is always present as the Clearwater rep \u2014 label him \"Austin (Clearwater)\"\n- If a speaker cannot be identified by name, label them by role if determinable (e.g., \"Client IT Director\") or as \"Client (Unknown)\" \u2014 never just \"Unknown\"\n- List every identified speaker with their name, role, and company before proceeding\n\nSTEP 2 \u2014 EXTRACT EVIDENCE BY P2V2C2 DIMENSION\nFor each of the six dimensions, extract every relevant statement from the transcript.\n\nRules:\n- Verbatim quotes ONLY \u2014 do not paraphrase, summarize, or interpret\n- Every quote must be attributed to the speaker identified in Step 1\n- Include the full quote with enough context to be unambiguous\n- If a quote is relevant to multiple dimensions, include it under each\n- If a dimension has zero supporting quotes, write \"No evidence found\"\n- Do not editorialize \u2014 your job is retrieval, not reasoning\n\nDimensions to extract for:\n- PAIN: Any expression of problems, frustrations, risks, compliance concerns, security gaps, regulatory pressure, or dissatisfaction with current state\n- POWER: Any signals about who has authority, budget control, decision-making, executive sponsorship, or organizational hierarchy\n- VISION: Any statements about desired future state, goals, what success looks like, or what the client wants to achieve\n- VALUE: Any statements about expected benefits, ROI, cost justification, or what solving the problem is worth\n- CHANGE: Any statements about urgency, timeline pressure, willingness to act, or commitment to moving forward\n- CONTROL: Any statements about the buying process, procurement requirements, approval steps, contract timelines, or decision criteria\n\nOUTPUT FORMAT\nReturn ONLY the following JSON \u2014 no preamble, no markdown fences:\n{\n  \"speakers\": [\n    {\"name\": \"\", \"role\": \"\", \"company\": \"\"}\n  ],\n  \"evidence\": {\n    \"pain\": \"\",\n    \"power\": \"\",\n    \"vision\": \"\",\n    \"value\": \"\",\n    \"change\": \"\",\n    \"control\": \"\"\n  }\n}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        384,
        64
      ],
      "name": "ECHO Pass 1 - Evidence",
      "alwaysOutputData": true,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        384,
        288
      ],
      "name": "GPT-4o Pass 1",
      "credentials": {
        "openAiApi": {
          "id": "fIeGh1UabUL1CBma",
          "name": "ECHO OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Handoff: Pass 1 Evidence \u2192 Pass 2 Scoring\nconst pass1 = $('ECHO Pass 1 - Evidence').item.json;\n\nfunction unwrap(node) {\n  const raw = node.output !== undefined ? node.output : node;\n  if (typeof raw === 'string') {\n    try {\n      const cleaned = raw.replace(/^```json\\s*/i, '').replace(/^```\\s*/i, '').replace(/```\\s*$/i, '').trim();\n      return JSON.parse(cleaned);\n    } catch(e) { return {}; }\n  }\n  return raw;\n}\n\nconst data = unwrap(pass1);\nconst speakers = data.speakers || [];\nconst evidence = data.evidence || {};\n\nconst speakerList = speakers.map(s => `- ${s.name} | ${s.role} | ${s.company}`).join('\\n') || 'No speakers identified.';\n\nconst content = `EVIDENCE DOCUMENT FOR P2V2C2 SCORING\n======================================\nThis document was produced by ECHO Pass 1 \u2014 Evidence Extractor.\nScore ONLY from the evidence below. Do not reference the original transcript.\n\nIDENTIFIED SPEAKERS\n-------------------\n${speakerList}\n\nEVIDENCE BY DIMENSION\n---------------------\n\nPAIN:\n${evidence.pain || 'No evidence found.'}\n\nPOWER:\n${evidence.power || 'No evidence found.'}\n\nVISION:\n${evidence.vision || 'No evidence found.'}\n\nVALUE:\n${evidence.value || 'No evidence found.'}\n\nCHANGE:\n${evidence.change || 'No evidence found.'}\n\nCONTROL:\n${evidence.control || 'No evidence found.'}`;\n\nreturn [{ json: { content, _pass1_raw: data } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        592,
        64
      ],
      "name": "Handoff 1 to 2",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.content }}",
        "options": {
          "systemMessage": "IDENTITY\nYou are ECHO Pass 2 \u2014 P2V2C2 Scorer. You receive a structured evidence document produced by ECHO Pass 1. Your only job is to score each of the six P2V2C2 dimensions using the rubric below. You do not generate artifacts. You do not summarize. You score and cite.\n\nTHE RUBRIC\nScore | Pain | Power | Vision | Value | Change | Control\n0 | No knowledge of pain | No idea who is power | No idea of needs | Benefits unknown | No one committed | Buying process unknown\n1 | PC shared situation | Indication of PES | Begun to define needs | Believe situation causes pain | PC open to change | C described process\n2 | PC admitted pain | Champion agreed to take to PES | Mapped capabilities to needs | Defined cost of pain | PC confirmed PES will meet | Met with PES\n3 | PC indicated pain of PES | Met with PES | Agreed to proof criteria | Believe solution addresses pain | PES agreed need to change | Pain admitted & vision created for ES\n4 | PES admitted pain | PES agreed to DAP | ES agreed to vision | ES shared benefits with DM | ES chosen Clearwater to lead change | ES agreed to DAP\n5 | ES agreed pain great enough to change | DAP steps on schedule | ES painting vision to others | DM agreed to financial terms | ES convinced DM must change | DAP complete\n\nPC=Potential Champion, PES=Potential Executive Sponsor, C=Champion, ES=Executive Sponsor, DM=Decision Maker\n\nSCORING RULES \u2014 READ CAREFULLY\n1. Read the evidence document. Do not re-read the original transcript. The evidence document is your only source of truth.\n2. For each dimension, find the HIGHEST rubric level that is DIRECTLY supported by a named quote in the evidence document.\n3. You MUST cite: (a) the exact rubric row text you are matching, (b) the speaker name and role, (c) the verbatim quote from the evidence document.\n4. If you cannot find a quote that directly supports a rubric level, you CANNOT score at that level. Score the level below.\n5. Score 0 if there is no evidence at all for a dimension.\n6. When the evidence is ambiguous between two levels, score the lower one.\n7. The evidence_description field follows this exact format: \"[Dimension] ([score]/5) - [Intensity]. [One sentence using the client's own words, speaker-attributed.]\"\n   Intensity: 0=None, 1=Minimal, 2=Low, 3=Medium, 4=High, 5=Very Strong\n\nOUTPUT FORMAT\nReturn ONLY the following JSON \u2014 no preamble, no markdown fences:\n{\n  \"scores\": {\n    \"pain\": {\n      \"score\": 0,\n      \"rubric_row_cited\": \"\",\n      \"speaker\": \"\",\n      \"verbatim_quote\": \"\",\n      \"evidence_description\": \"\"\n    },\n    \"power\": {\n      \"score\": 0,\n      \"rubric_row_cited\": \"\",\n      \"speaker\": \"\",\n      \"verbatim_quote\": \"\",\n      \"evidence_description\": \"\"\n    },\n    \"vision\": {\n      \"score\": 0,\n      \"rubric_row_cited\": \"\",\n      \"speaker\": \"\",\n      \"verbatim_quote\": \"\",\n      \"evidence_description\": \"\"\n    },\n    \"value\": {\n      \"score\": 0,\n      \"rubric_row_cited\": \"\",\n      \"speaker\": \"\",\n      \"verbatim_quote\": \"\",\n      \"evidence_description\": \"\"\n    },\n    \"change\": {\n      \"score\": 0,\n      \"rubric_row_cited\": \"\",\n      \"speaker\": \"\",\n      \"verbatim_quote\": \"\",\n      \"evidence_description\": \"\"\n    },\n    \"control\": {\n      \"score\": 0,\n      \"rubric_row_cited\": \"\",\n      \"speaker\": \"\",\n      \"verbatim_quote\": \"\",\n      \"evidence_description\": \"\"\n    }\n  }\n}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        800,
        64
      ],
      "name": "ECHO Pass 2 - Scoring",
      "alwaysOutputData": true,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        800,
        288
      ],
      "name": "GPT-4o Pass 2",
      "credentials": {
        "openAiApi": {
          "id": "fIeGh1UabUL1CBma",
          "name": "ECHO OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Handoff: Pass 1 + Pass 2 \u2192 Pass 3 Artifact Generation\nconst pass1 = $('ECHO Pass 1 - Evidence').item.json;\nconst pass2 = $('ECHO Pass 2 - Scoring').item.json;\nconst input = $('Input Classifier').item.json;\nconst dealContext = $('Merge Deal Context').item.json;\n\nfunction unwrap(node) {\n  const raw = node.output !== undefined ? node.output : node;\n  if (typeof raw === 'string') {\n    try {\n      const cleaned = raw.replace(/^```json\\s*/i, '').replace(/^```\\s*/i, '').replace(/```\\s*$/i, '').trim();\n      return JSON.parse(cleaned);\n    } catch(e) { return {}; }\n  }\n  return raw;\n}\n\nconst data1 = unwrap(pass1);\nconst data2 = unwrap(pass2);\nconst speakers = data1.speakers || [];\nconst evidence = data1.evidence || {};\nconst scores = data2.scores || {};\n\nconst speakerList = speakers.map(s => `- ${s.name} | ${s.role} | ${s.company}`).join('\\n') || 'None identified.';\n\nfunction scoreBlock(dim) {\n  const s = scores[dim] || {};\n  return `${dim.toUpperCase()}: ${s.score || 0}/5\n  Rubric row cited: ${s.rubric_row_cited || 'none'}\n  Speaker: ${s.speaker || 'unknown'}\n  Quote: \"${s.verbatim_quote || ''}\"\n  Evidence description: ${s.evidence_description || ''}`;\n}\n\nconst priorHistory = dealContext?.cas_current \n  ? `Prior CAS: ${dealContext.cas_current}\\nPrior scores \u2014 Pain:${dealContext.pain_score||0} Power:${dealContext.power_score||0} Vision:${dealContext.vision_score||0} Value:${dealContext.value_score||0} Change:${dealContext.change_score||0} Control:${dealContext.control_score||0}`\n  : 'First run \u2014 no prior deal history.';\n\nconst content = `DEAL RECORD FOR ARTIFACT GENERATION\n=====================================\nDeal: ${input.deal_slug || 'unknown'}\nAccount: ${input.account_name || dealContext?.account_name || 'unknown'}\nInput Type: ${input.input_type || 'unknown'}\nDate: ${input.date || 'unknown'}\n\nIDENTIFIED SPEAKERS\n-------------------\n${speakerList}\n\nEVIDENCE DOCUMENT (verbatim, speaker-attributed \u2014 treat as ground truth)\n------------------------------------------------------------------------\nPAIN:\n${evidence.pain || 'No evidence found.'}\n\nPOWER:\n${evidence.power || 'No evidence found.'}\n\nVISION:\n${evidence.vision || 'No evidence found.'}\n\nVALUE:\n${evidence.value || 'No evidence found.'}\n\nCHANGE:\n${evidence.change || 'No evidence found.'}\n\nCONTROL:\n${evidence.control || 'No evidence found.'}\n\nLOCKED P2V2C2 SCORES (from Pass 2 \u2014 do not re-score, use these exactly)\n------------------------------------------------------------------------\n${scoreBlock('pain')}\n\n${scoreBlock('power')}\n\n${scoreBlock('vision')}\n\n${scoreBlock('value')}\n\n${scoreBlock('change')}\n\n${scoreBlock('control')}\n\nPRIOR DEAL HISTORY\n------------------\n${priorHistory}\n\nRAW INPUT\n---------\n${(input.content || '').substring(0, 8000)}`;\n\nreturn [{ json: { content } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1008,
        64
      ],
      "name": "Handoff 2 to 3",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.content }}",
        "options": {
          "systemMessage": "IDENTITY\nYou are ECHO Pass 3 \u2014 Artifact Engine. You are an expert Sales Assistant for Austin Holland, Sales Executive at Clearwater Security & Compliance, PPM (Physician Practice Management) team. You receive a fully grounded deal record \u2014 structured evidence, locked P2V2C2 scores with citations, deal history \u2014 and produce all deal artifacts.\n\nKNOWLEDGE TOOLS\nUse the clearwater_knowledge_base tool to ensure all service descriptions use correct Clearwater terminology (MSS, MDR, IRM|Analysis, IRM|Pro, ClearAdvantage, vCISO, Technical Testing, Privacy & Compliance, etc.).\n\nKEY ASSUMPTIONS\n- Anchor Date: The date the input is submitted is the discovery call date unless stated otherwise.\n- DAP Projections: If DAP dates are not explicitly agreed upon, project logical future dates from the Anchor Date using standard cadence (Co-Create ~1 week after discovery). Never leave dates blank.\n- Keep all deal data strictly isolated \u2014 never mix with other deals.\n\nPHASE 1 \u2014 SALESFORCE DATA\nProduce all Phase 1 fields grounded in the locked scores and evidence.\n\nClose Date: [Date] (Execute contract - [STATUS])\nStage: [Created/Discover/Qualify/Prove/Close]\nCritical Activity Stage (CAS): e.g., [2A: Discovery, Define Current State]\nForecast Category: [Omitted/Pipeline/Upside/Commit/Negotiate/Closed]\n\nDAP Block:\nDAP Status: [Confirmed by client OR Internal Draft]\n\nTimeline:\n[Date] - Initial Discovery [STATUS]\n[Date] - Define Current State and Desired Future State [STATUS]\n[Date] - Co-Create Session [STATUS]\n[Date] - Present Draft Approach [STATUS]\n[Date] - Present updated Approach based on feedback [STATUS]\n[Date] - Go / No Go Decision [STATUS]\n[Date] - Submit for Budget Approval [STATUS]\n[Date] - Send MSA/SOW [STATUS]\n[Date] - [Client Name] Initial Review of MSA / SOW & redlines [STATUS]\n[Date] - Call to Review Redlines [STATUS]\n[Date] - Finalize Redlines and launch DocuSign [STATUS]\n[Date] - Execute contract [STATUS]\n[Date] - Initial Engagement Meeting / Project Start [STATUS]\n[Date] - Final report delivered to [Client name] [STATUS]\n\nCurrent State:\nORGANIZATION: [text]\nACTIVITIES: [text]\nTECHNOLOGY: [text]\n\nFuture & Desired State:\nORGANIZATION: [text]\nACTIVITIES: [text]\nTECHNOLOGY: [text]\n\nKey Stakeholder Success Criteria:\nTO THE BOARD: [text]\n[STAKEHOLDER NAME/ROLE]: [text]\n\nRisks: [text]\nNext Step: [text]\n\nPHASE 2 \u2014 NARRATIVE ARTIFACTS\nProduce all nine narrative artifacts grounded in the evidence and scores above.\n\n1) call_summary: Concise factual summary \u2014 what happened, who participated, key outcomes.\n\n2) highlights: The 5-7 most important moments or statements from the call, as bullet points.\n\n3) action_items: Next steps with owners. Both explicitly mentioned and logically implied by deal stage.\n\n4) p2v2c2_scoring: Written narrative assessment of all six scores \u2014 why each was assigned, what's strong, what's exposed. Not a table.\n\n5) internal_actions: Internal-only action items for Austin and the Clearwater team. What needs to be prepared, researched, or produced to advance the deal cycle as fast as possible.\n\n6) services_narrative: All services, workstreams, or products mentioned or implied. Exact Clearwater service names. Scope, timing, client sentiment, named colleagues.\n\n7) general_narrative: Full narrative of all inputs with a closing conclusion on how to best close the highest possible TCV given the full deal context.\n\n8) anecdotes: Notable behavioral patterns, cultural signals, or observations that could aid future deal insights.\n\n9) internal_team_update:\nTone: Astute, eloquent, professional. Subtle dry sarcasm on corporate behaviors or delays.\nStructure:\nOpportunity Source: (Where did this come from?)\nDAP Review: (Brief status check)\nCurrent/Future State Narrative: (No bullets \u2014 write a narrative story about the client's plight and path to desired future state.)\nP2V2C2 Strengths & Weaknesses: (Where are we strong, where are we exposed?)\nWinning Strategy: (How we close this)\nLeadership Help: (Ask for specific help if needed; otherwise state \"under control\")\n\nOUTPUT FORMAT\nReturn ONLY the following JSON \u2014 no preamble, no markdown fences:\n{\n  \"salesforce\": {\n    \"close_date\": \"\",\n    \"stage\": \"\",\n    \"cas\": \"\",\n    \"forecast_category\": \"\",\n    \"salesforce_block_1_dap\": \"\",\n    \"risks\": \"\",\n    \"next_step\": \"\",\n    \"pain_score\": 0,\n    \"pain_evidence\": \"\",\n    \"power_score\": 0,\n    \"power_evidence\": \"\",\n    \"vision_score\": 0,\n    \"vision_evidence\": \"\",\n    \"value_score\": 0,\n    \"value_evidence\": \"\",\n    \"change_score\": 0,\n    \"change_evidence\": \"\",\n    \"control_score\": 0,\n    \"control_evidence\": \"\"\n  },\n  \"narratives\": {\n    \"call_summary\": \"\",\n    \"highlights\": \"\",\n    \"action_items\": \"\",\n    \"p2v2c2_scoring\": \"\",\n    \"internal_actions\": \"\",\n    \"services_narrative\": \"\",\n    \"general_narrative\": \"\",\n    \"anecdotes\": \"\",\n    \"internal_team_update\": \"\"\n  }\n}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        1216,
        64
      ],
      "name": "ECHO Pass 3 - Artifacts",
      "alwaysOutputData": true,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "options": {
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1216,
        288
      ],
      "name": "GPT-4o Pass 3",
      "credentials": {
        "openAiApi": {
          "id": "fIeGh1UabUL1CBma",
          "name": "ECHO OpenAI API"
        }
      }
    }
  ],
  "connections": {
    "Gmail Trigger - Deal Inputs": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Triggers": {
      "main": [
        [
          {
            "node": "Input Classifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Input Classifier": {
      "main": [
        [
          {
            "node": "Load Deal Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Deal Memory": {
      "main": [
        [
          {
            "node": "Validate Deal Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Deal Memory": {
      "main": [
        [
          {
            "node": "Check Deal Exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format for PostgreSQL": {
      "main": [
        [
          {
            "node": "Open Review Portal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Review (Editing Portal)": {
      "main": [
        [
          {
            "node": "Merge Edited Artifacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Edited Artifacts": {
      "main": [
        [
          {
            "node": "Check if New Deal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if New Deal": {
      "main": [
        [
          {
            "node": "Insert New Deal",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Existing Deal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert New Deal": {
      "main": [
        [
          {
            "node": "Save Artifacts",
            "type": "main",
            "index": 0
          },
          {
            "node": "Save Artifact Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Existing Deal": {
      "main": [
        [
          {
            "node": "Save Artifacts",
            "type": "main",
            "index": 0
          },
          {
            "node": "Save Artifact Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Artifacts": {
      "main": [
        [
          {
            "node": "Save P2V2C2 Evidence",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save P2V2C2 Evidence": {
      "main": [
        [
          {
            "node": "Save History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save History": {
      "main": [
        [
          {
            "node": "Gmail - Send Artifacts Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Deal Exists": {
      "main": [
        [
          {
            "node": "Merge Deal Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Opportunity",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New Opportunity": {
      "main": [
        [
          {
            "node": "Merge Deal Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Open Review Portal": {
      "main": [
        [
          {
            "node": "Wait for Review (Editing Portal)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Embeddings": {
      "ai_embedding": [
        [
          {
            "node": "ECHO Knowledge Base (PGVector)",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "ECHO Knowledge Base (PGVector)": {
      "ai_tool": [
        [
          {
            "node": "ECHO Pass 3 - Artifacts",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Merge Deal Context": {
      "main": [
        [
          {
            "node": "ECHO Pass 1 - Evidence",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ECHO Pass 1 - Evidence": {
      "main": [
        [
          {
            "node": "Handoff 1 to 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GPT-4o Pass 1": {
      "ai_languageModel": [
        [
          {
            "node": "ECHO Pass 1 - Evidence",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Handoff 1 to 2": {
      "main": [
        [
          {
            "node": "ECHO Pass 2 - Scoring",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ECHO Pass 2 - Scoring": {
      "main": [
        [
          {
            "node": "Handoff 2 to 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GPT-4o Pass 2": {
      "ai_languageModel": [
        [
          {
            "node": "ECHO Pass 2 - Scoring",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Handoff 2 to 3": {
      "main": [
        [
          {
            "node": "ECHO Pass 3 - Artifacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ECHO Pass 3 - Artifacts": {
      "main": [
        [
          {
            "node": "Format for PostgreSQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GPT-4o Pass 3": {
      "ai_languageModel": [
        [
          {
            "node": "ECHO Pass 3 - Artifacts",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "binaryMode": "separate"
  },
  "tags": [],
  "active": true,
  "isArchived": false
}