{
  "id": "RlnZGOaKU4ee7D6M",
  "name": "ECHOv4 - PostgreSQL_TESTING",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyX",
              "value": 1,
              "unit": "minutes"
            }
          ]
        },
        "simple": false,
        "filters": {
          "sender": "austin.holland@clearwatersecurity.com"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1.3,
      "position": [
        -896,
        256
      ],
      "name": "Gmail Trigger - Deal Inputs",
      "alwaysOutputData": false,
      "executeOnce": false,
      "credentials": {
        "gmailOAuth2": {
          "id": "KcxcROH9oa3L7IUB",
          "name": "Gmail ECHO"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Classify input type and extract content\nconst items = $input.all();\nconst results = [];\n\n// Helper: Normalize account name to slug format\nfunction normalizeToSlug(text) {\n  if (!text) return null;\n  return text\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')  // Replace non-alphanumeric with dashes\n    .replace(/^-+|-+$/g, '')      // Trim leading/trailing dashes\n    .replace(/-+/g, '-');          // Collapse multiple dashes\n}\n\nfor (const item of items) {\n  // Check if input is from webhook (MCP) or Gmail\n  const isWebhook = item.json.body !== undefined;\n  \n  let content, subject, input_type, deal_slug, salesforce_opportunity_id, date, source_filename;\n  let opportunity_name, account_name, close_date, trigger_type;\n  \n  if (isWebhook) {\n    // MCP/Webhook input - convert camelCase to snake_case\n    const body = item.json.body;\n    // Generate content from webhook fields if not provided\n    if (body.content) {\n      content = body.content;\n    } else {\n      // Build descriptive content from available fields\n      const parts = [];\n      if (trigger_type && trigger_type !== 'deal_intake') {\n        parts.push(`${trigger_type}`);\n      } else {\n        parts.push('New deal opportunity');\n      }\n      \n      if (opportunity_name) {\n        parts.push(`\"${opportunity_name}\"`);\n      }\n      \n      if (account_name) {\n        parts.push(`at ${account_name}`);\n      }\n      \n      if (close_date) {\n        parts.push(`(expected close: ${close_date})`);\n      }\n      \n      content = parts.join(' ') + '. This is initial deal intake with minimal information.';\n    }\n    input_type = body.input_type || body.inputType || 'call_transcript';\n    opportunity_name = body.opportunity_name || body.opportunityName || null;\n    account_name = body.account_name || body.accountName || null;\n    close_date = body.close_date || body.closeDate || null;\n    trigger_type = body.trigger_type || body.triggerType || 'deal_intake';\n    salesforce_opportunity_id = body.salesforce_opportunity_id || body.salesforceOpportunityId || null;\n    date = body.date || new Date().toISOString().split('T')[0];\n    source_filename = body.source_filename || body.sourceFilename || 'mcp-input';\n    \n    // Slug generation logic:\n    // 1. Use provided slug if exists\n    // 2. Normalize account_name if provided\n    // 3. Fall back to date-based slug\n    if (body.deal_slug || body.dealSlug) {\n      deal_slug = body.deal_slug || body.dealSlug;\n    } else if (account_name) {\n      const accountSlug = normalizeToSlug(account_name);\n      deal_slug = `${accountSlug}-${date}`;\n    } else {\n      deal_slug = `deal-${date}`;\n    }\n    \n  } else {\n    // Gmail input\n    subject = item.json.subject || '';\n    const text = item.json.text || item.json.textPlain || '';\n    content = text;\n    \n    // Check for X-ECHO-Deal-Slug header first (most reliable)\n    const headers = item.json.headers || {};\n    const echoSlugHeader = headers['x-echo-deal-slug'] || headers['X-ECHO-Deal-Slug'] || headers['X-Echo-Deal-Slug'];\n    \n    if (echoSlugHeader) {\n      deal_slug = echoSlugHeader;\n    } else {\n      // Strip email prefixes (Re:, Fwd:, FW:, etc.) then extract account name\n      const cleanSubject = subject.replace(/^(Re:|Fwd:|FW:|RE:|FWD:)\\s*/gi, '').trim();\n      const subjectMatch = cleanSubject.match(/^([^-]+)/);\n      if (subjectMatch) {\n        const extractedAccount = subjectMatch[1].trim();\n        account_name = extractedAccount;\n        deal_slug = `${normalizeToSlug(extractedAccount)}-${new Date().toISOString().split('T')[0]}`;\n      } else {\n        deal_slug = `deal-${new Date().toISOString().split('T')[0]}`;\n      }\n    }\n    \n    // Determine input type\n    input_type = 'email';\n    if (subject.toLowerCase().includes('transcript')) {\n      input_type = 'call_transcript';\n    } else if (subject.toLowerCase().includes('notes')) {\n      input_type = 'call_notes';\n    }\n    \n    salesforce_opportunity_id = null;\n    date = new Date().toISOString().split('T')[0];\n    source_filename = `email-${item.json.id || 'unknown'}`;\n    opportunity_name = null;\n    close_date = null;\n    trigger_type = 'email_trigger';\n  }\n  \n  results.push({\n    json: {\n      content: content,\n      subject: subject,\n      input_type: input_type,\n      deal_slug: deal_slug,\n      salesforce_opportunity_id: salesforce_opportunity_id,\n      date: date,\n      source_filename: source_filename,\n      opportunity_name: opportunity_name,\n      account_name: account_name,\n      close_date: close_date,\n      trigger_type: trigger_type\n    }\n  });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        160
      ],
      "name": "Input Classifier"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM deals \nWHERE salesforce_opportunity_id = '{{ $json.salesforce_opportunity_id }}'\n   OR deal_slug = '{{ $json.deal_slug }}'\n   OR (account_name IS NOT NULL \n       AND account_name ILIKE '{{ $json.account_name }}%')\nORDER BY \n  CASE \n    WHEN deal_slug = '{{ $json.deal_slug }}' THEN 1\n    WHEN salesforce_opportunity_id = '{{ $json.salesforce_opportunity_id }}' THEN 2\n    ELSE 3\n  END,\n  updated_at DESC\nLIMIT 1",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -464,
        160
      ],
      "name": "Load Deal Memory",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      },
      "continueOnFail": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\n// Get input data using correct n8n syntax\nconst inputData = $('Input Classifier').item.json;\n\n// Check what we got from Load Deal Memory\nconst dealData = items?.[0]?.json;\nconst idValue = dealData?.id;\n\n// Check for valid deal - id must be a positive number\nconst hasValidDeal = typeof idValue === 'number' && idValue > 0;\n\nif (!hasValidDeal) {\n  // No valid deal\n  return [{ \n    json: { \n      _noDealsFound: true,\n      _contextSource: 'new_opportunity',\n      deal_slug: inputData.deal_slug,\n      opportunity_name: inputData.opportunity_name,\n      account_name: inputData.account_name,\n      close_date: inputData.close_date,\n      salesforce_opportunity_id: inputData.salesforce_opportunity_id,\n      trigger_type: inputData.trigger_type,\n      content: inputData.content,\n      input_type: inputData.input_type\n    }\n  }];\n}\n\n// Deal found\nreturn [{ \n  json: {\n    ...dealData,\n    _noDealsFound: false,\n    _contextSource: 'existing_deal',\n    content: inputData.content\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        32
      ],
      "name": "Validate Deal Memory",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.content }}",
        "options": {
          "systemMessage": "IDENTITY\nYou are ECHO Intelligence Engine \u2014 an expert deal analyst for Austin Holland, Sales Executive at Clearwater Security & Compliance, PPM (Physician Practice Management) team. You are a consummate professional and seasoned sales strategist with deep Clearwater domain knowledge.\n\nKeep all deal data strictly isolated \u2014 never mix evidence from different deals.\n\nKNOWLEDGE TOOLS\nUse the clearwater_knowledge_base tool to look up Clearwater service terminology (MSS, MDR, IRM|Analysis, IRM|Pro, ClearAdvantage, vCISO, Technical Testing, Privacy & Compliance, etc.) before writing service descriptions. Do NOT use the knowledge base to look up the P2V2C2 rubric \u2014 it is defined below.\n\nKEY ASSUMPTIONS\n- Anchor Date: The date the input is submitted is the discovery call date unless stated otherwise.\n- DAP Projections: If DAP dates are not explicitly agreed upon, project logical future dates from the Anchor Date using a standard successful cadence (Co-Create ~1 week after discovery, etc.). Never leave dates blank.\n\n==============================================================\nTASK 1 \u2014 EVIDENCE EXTRACTION\n==============================================================\nRead the raw input. Produce a structured, speaker-attributed evidence document.\n\nRules:\n- Verbatim quotes ONLY. No paraphrase, no interpretation.\n- Every claim must be attributed to a named speaker (e.g., \"Dr. Smith (CMO)\", \"Austin\", \"Unknown\").\n- Organize by P2V2C2 dimension: Pain, Power, Vision, Value, Change, Control.\n- If a speaker says something relevant to multiple dimensions, list it under each.\n- If a dimension has zero evidence, write \"No evidence found.\"\n\n==============================================================\nTASK 2 \u2014 P2V2C2 SCORING\n==============================================================\nUsing ONLY the evidence you extracted in Task 1, score each dimension 0-5 using this rubric:\n\nScore | Pain | Power | Vision | Value | Change | Control\n0 | No knowledge of pain | No idea who is power | No idea of needs | Benefits unknown | No one committed | Buying process unknown\n1 | PC shared situation | Indication of PES | Begun to define needs | Believe situation causes pain | PC open to change | C described process\n2 | PC admitted pain | Champion agreed to take to PES | Mapped capabilities to needs | Defined cost of pain | PC confirmed PES will meet | Met with PES\n3 | PC indicated pain of PES | Met with PES | Agreed to proof criteria | Believe solution addresses pain | PES agreed need to change | Pain admitted & vision created for ES\n4 | PES admitted pain | PES agreed to DAP | ES agreed to vision | ES shared benefits with DM | ES chosen Clearwater to lead change | ES agreed to DAP\n5 | ES agreed pain great enough to change | DAP steps on schedule | ES painting vision to others | DM agreed to financial terms | ES convinced DM must change | DAP complete\n\nPC=Potential Champion, PES=Potential Executive Sponsor, C=Champion, ES=Executive Sponsor, DM=Decision Maker\n\nScoring rules:\n- Score the HIGHEST level that is DIRECTLY supported by a verbatim quote from Task 1.\n- You MUST cite: (a) the specific rubric row you are scoring, (b) the speaker name, (c) the verbatim quote.\n- You CANNOT score a level you cannot cite. If evidence is ambiguous, score lower.\n- Evidence descriptions follow this format: \"[Dimension] ([score]/5) - [Intensity]. [One sentence using the client's own words, attributed to speaker.]\"\n- Intensity mapping: 0=None, 1=Minimal, 2=Low, 3=Medium, 4=High, 5=Very Strong\n\n==============================================================\nTASK 3 \u2014 PHASE 1: SALESFORCE DATA\n==============================================================\nProduce all Phase 1 Salesforce artifacts using the scores and evidence from Tasks 1-2.\n\nClose Date: [Date] (Execute contract - [STATUS])\nStage: [Created/Discover/Qualify/Prove/Close]\nCritical Activity Stage (CAS): e.g., [2A: Discovery, Define Current State]\nForecast Category: [Omitted/Pipeline/Upside/Commit/Negotiate/Closed]\n\nDAP Block format:\nDAP Status: [Confirmed by client OR Internal Draft]\n\nTimeline:\n[Date] - Initial Discovery [STATUS]\n[Date] - Define Current State and Desired Future State [STATUS]\n[Date] - Co-Create Session [STATUS]\n[Date] - Present Draft Approach [STATUS]\n[Date] - Present updated Approach based on feedback [STATUS]\n[Date] - Go / No Go Decision [STATUS]\n[Date] - Submit for Budget Approval [STATUS]\n[Date] - Send MSA/SOW [STATUS]\n[Date] - [Client Name] Initial Review of MSA / SOW & redlines [STATUS]\n[Date] - Call to Review Redlines [STATUS]\n[Date] - Finalize Redlines and launch DocuSign [STATUS]\n[Date] - Execute contract [STATUS]\n[Date] - Initial Engagement Meeting / Project Start [STATUS]\n[Date] - Final report delivered to [Client name] [STATUS]\n\nCurrent State:\nORGANIZATION: [text]\nACTIVITIES: [text]\nTECHNOLOGY: [text]\n\nFuture & Desired State:\nORGANIZATION: [text]\nACTIVITIES: [text]\nTECHNOLOGY: [text]\n\nKey Stakeholder Success Criteria:\nTO THE BOARD: [text]\n[STAKEHOLDER NAME/ROLE]: [text]\n\nRisks: [text]\nNext Step: [text]\n\n==============================================================\nOUTPUT FORMAT\n==============================================================\nReturn ONLY the following JSON object \u2014 no preamble, no markdown fences:\n{\n  \"evidence\": {\n    \"pain\": \"\",\n    \"power\": \"\",\n    \"vision\": \"\",\n    \"value\": \"\",\n    \"change\": \"\",\n    \"control\": \"\"\n  },\n  \"salesforce\": {\n    \"close_date\": \"\",\n    \"stage\": \"\",\n    \"cas\": \"\",\n    \"forecast_category\": \"\",\n    \"salesforce_block_1_dap\": \"\",\n    \"risks\": \"\",\n    \"next_step\": \"\",\n    \"pain_score\": 0,\n    \"pain_evidence\": \"\",\n    \"power_score\": 0,\n    \"power_evidence\": \"\",\n    \"vision_score\": 0,\n    \"vision_evidence\": \"\",\n    \"value_score\": 0,\n    \"value_evidence\": \"\",\n    \"change_score\": 0,\n    \"change_evidence\": \"\",\n    \"control_score\": 0,\n    \"control_evidence\": \"\"\n  }\n}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        384,
        64
      ],
      "name": "ECHO Intelligence Engine",
      "alwaysOutputData": true,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsonSchemaExample": "={{ {} }}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        528,
        288
      ],
      "name": "Structured Output Parser Agent 1"
    },
    {
      "parameters": {
        "jsCode": "// Format outputs from both ECHO agents for PostgreSQL and review portal\nconst agent1 = $('ECHO Intelligence Engine').item.json;\nconst agent2 = $('ECHO Artifact Engine').item.json;\nconst input = $('Input Classifier').item.json;\nconst dealContext = $('Merge Deal Context').item.json;\n\nif (!agent1 || !input) {\n  throw new Error('Missing required data from ECHO Intelligence Engine or Input Classifier');\n}\n\nfunction esc(val) {\n  if (val === null || val === undefined || val === '') return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction escStr(val) {\n  if (val === null || val === undefined) return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction escNum(val) {\n  const n = Number(val);\n  return isNaN(n) ? '0' : String(n);\n}\n\nfunction unwrap(node) {\n  const raw = node.output !== undefined ? node.output : node;\n  if (typeof raw === 'string') {\n    try {\n      const cleaned = raw.replace(/^```json\\s*/i, '').replace(/^```\\s*/i, '').replace(/```\\s*$/i, '').trim();\n      return JSON.parse(cleaned);\n    } catch(e) { return {}; }\n  }\n  return raw;\n}\n\nconst data1 = unwrap(agent1);\nconst sf = data1.salesforce || {};\n\nconst data2 = unwrap(agent2);\nconst narr = data2.narratives || {};\n\nfunction extractStageCode(casStr) {\n  if (!casStr) return '1A';\n  const match = casStr.match(/^([1-5][AB])/i);\n  if (match) return match[1].toUpperCase();\n  const s = casStr.toLowerCase();\n  if (s.includes('close') || s.includes('won') || s.includes('lost')) return '5A';\n  if (s.includes('negot') || s.includes('contract') || s.includes('msa') || s.includes('sow')) return '4A';\n  if (s.includes('prov') || s.includes('valid') || s.includes('proposal') || s.includes('demo')) return '3A';\n  if (s.includes('qualif') || s.includes('engaged') || s.includes('discover')) return '2A';\n  return '1A';\n}\n\nconst deal_slug = input.deal_slug || '';\nconst salesforce_opportunity_id = dealContext?.salesforce_opportunity_id || input.salesforce_opportunity_id || null;\nconst opportunity_name = input.opportunity_name || dealContext?.opportunity_name || '';\nconst account_name = input.account_name || dealContext?.account_name || '';\n\nconst close_date = sf.close_date || null;\nconst stage = sf.stage || '';\nconst cas = sf.cas || '';\nconst forecast_category = sf.forecast_category || '';\nconst salesforce_block_1_dap = sf.salesforce_block_1_dap || '';\nconst risks = sf.risks || '';\nconst next_step = sf.next_step || '';\n\nconst pain_score = Number(sf.pain_score) || 0;\nconst pain_evidence = sf.pain_evidence || '';\nconst power_score = Number(sf.power_score) || 0;\nconst power_evidence = sf.power_evidence || '';\nconst vision_score = Number(sf.vision_score) || 0;\nconst vision_evidence = sf.vision_evidence || '';\nconst value_score = Number(sf.value_score) || 0;\nconst value_evidence = sf.value_evidence || '';\nconst change_score = Number(sf.change_score) || 0;\nconst change_evidence = sf.change_evidence || '';\nconst control_score = Number(sf.control_score) || 0;\nconst control_evidence = sf.control_evidence || '';\nconst p2v2c2_total = pain_score + power_score + vision_score + value_score + change_score + control_score;\n\nconst call_summary = narr.call_summary || '';\nconst highlights = narr.highlights || '';\nconst action_items = narr.action_items || '';\nconst p2v2c2_scoring = narr.p2v2c2_scoring || '';\nconst internal_actions = narr.internal_actions || '';\nconst services_narrative = narr.services_narrative || '';\nconst general_narrative = narr.general_narrative || '';\nconst anecdotes = narr.anecdotes || '';\nconst internal_team_update = narr.internal_team_update || '';\n\nconst stage_code = extractStageCode(cas);\nconst cas_confidence = 'medium';\nconst event_type = input.input_type || '';\nconst event_date = input.date || new Date().toISOString().split('T')[0];\nconst summary_str = `Processed ${input.input_type} - CAS: ${cas || 'N/A'}`;\nconst link_or_ref = input.source_filename || '';\nconst raw_content = (input.content || '').substring(0, 5000);\n\nconst insertDealSQL = `INSERT INTO deals (\n  deal_slug, salesforce_opportunity_id, outputs_version,\n  opportunity_name, account_name, stage, cas_current, cas_next, cas_confidence,\n  pain_score, power_score, vision_score, value_score, change_score, control_score\n) VALUES (\n  ${esc(deal_slug)}, ${esc(salesforce_opportunity_id)}, 'v4',\n  ${escStr(opportunity_name)}, ${escStr(account_name)}, ${escStr(stage_code)},\n  ${escStr(cas)}, ${escStr('')}, ${escStr(cas_confidence)},\n  ${escNum(pain_score)}, ${escNum(power_score)}, ${escNum(vision_score)},\n  ${escNum(value_score)}, ${escNum(change_score)}, ${escNum(control_score)}\n)\nON CONFLICT (deal_slug) DO UPDATE SET\n  salesforce_opportunity_id = EXCLUDED.salesforce_opportunity_id,\n  outputs_version = EXCLUDED.outputs_version,\n  opportunity_name = EXCLUDED.opportunity_name,\n  account_name = EXCLUDED.account_name,\n  stage = EXCLUDED.stage,\n  cas_current = EXCLUDED.cas_current,\n  cas_confidence = EXCLUDED.cas_confidence,\n  pain_score = EXCLUDED.pain_score,\n  power_score = EXCLUDED.power_score,\n  vision_score = EXCLUDED.vision_score,\n  value_score = EXCLUDED.value_score,\n  change_score = EXCLUDED.change_score,\n  control_score = EXCLUDED.control_score,\n  updated_at = CURRENT_TIMESTAMP\nRETURNING id`;\n\nconst updateDealSQL = `UPDATE deals SET\n  salesforce_opportunity_id = ${esc(salesforce_opportunity_id)},\n  outputs_version = 'v4',\n  opportunity_name = ${escStr(opportunity_name)},\n  account_name = ${escStr(account_name)},\n  stage = ${escStr(stage_code)},\n  cas_current = ${escStr(cas)},\n  cas_confidence = ${escStr(cas_confidence)},\n  close_date = ${close_date ? escStr(close_date) : 'NULL'},\n  updated_at = CURRENT_TIMESTAMP\nWHERE deal_slug = ${esc(deal_slug)}\nRETURNING *`;\n\nconst saveArtifactsSQL = `INSERT INTO artifacts (\n  deal_id,\n  salesforce_block_1_dap,\n  salesforce_pain_description, salesforce_power_description,\n  salesforce_vision_description, salesforce_value_description,\n  salesforce_change_description, salesforce_control_description,\n  approved\n) VALUES (\n  (SELECT id FROM deals WHERE deal_slug = ${esc(deal_slug)}),\n  ${esc(salesforce_block_1_dap)},\n  ${esc(pain_evidence)}, ${esc(power_evidence)},\n  ${esc(vision_evidence)}, ${esc(value_evidence)},\n  ${esc(change_evidence)}, ${esc(control_evidence)},\n  false\n)\nRETURNING id`;\n\nconst saveEvidenceSQL = `INSERT INTO p2v2c2_evidence (\n  deal_id, pain_score, pain_evidence, power_score, power_evidence,\n  vision_score, vision_evidence, value_score, value_evidence,\n  change_score, change_evidence, control_score, control_evidence, p2v2c2_total\n) VALUES (\n  (SELECT id FROM deals WHERE deal_slug = ${esc(deal_slug)}),\n  ${escNum(pain_score)}, ${esc(pain_evidence)},\n  ${escNum(power_score)}, ${esc(power_evidence)},\n  ${escNum(vision_score)}, ${esc(vision_evidence)},\n  ${escNum(value_score)}, ${esc(value_evidence)},\n  ${escNum(change_score)}, ${esc(change_evidence)},\n  ${escNum(control_score)}, ${esc(control_evidence)},\n  ${escNum(p2v2c2_total)}\n)\nRETURNING id`;\n\nconst saveHistorySQL = `INSERT INTO deal_history (\n  deal_id, event_type, event_source, event_date, summary,\n  link_or_ref, raw_content, cas_at_time, p2v2c2_total_at_time\n) VALUES (\n  (SELECT id FROM deals WHERE deal_slug = ${esc(deal_slug)}),\n  ${escStr(event_type)}, ${esc('')}, ${escStr(event_date)}::date,\n  ${escStr(summary_str)}, ${esc(link_or_ref)}, ${escStr(raw_content)},\n  ${escStr(cas)}, ${escNum(p2v2c2_total)}\n)\nRETURNING id`;\n\nconst deal = {\n  deal_slug, salesforce_opportunity_id, outputs_version: 'v4',\n  opportunity_name, account_name, stage: stage_code,\n  cas_current: cas, cas_next: '', cas_confidence, close_date,\n  pain_score, power_score, vision_score, value_score, change_score, control_score\n};\n\nreturn [{\n  json: {\n    deal,\n    _contextSource: dealContext?._contextSource || 'unknown',\n    insertDealSQL, updateDealSQL, saveArtifactsSQL, saveEvidenceSQL, saveHistorySQL,\n    close_date, stage, cas, forecast_category,\n    salesforce_block_1_dap, risks, next_step,\n    pain_score, pain_evidence,\n    power_score, power_evidence,\n    vision_score, vision_evidence,\n    value_score, value_evidence,\n    change_score, change_evidence,\n    control_score, control_evidence,\n    p2v2c2_total,\n    call_summary, highlights, action_items, p2v2c2_scoring,\n    internal_actions, services_narrative, general_narrative,\n    anecdotes, internal_team_update\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        64
      ],
      "name": "Format for PostgreSQL"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://host.docker.internal:5679/receive",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"execution_id\": \"{{ $execution.id }}\"\n}",
        "options": {
          "timeout": 5000,
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        800,
        280
      ],
      "name": "Open Review Portal"
    },
    {
      "parameters": {
        "resume": "form",
        "formTitle": "Review & Edit Deal Artifacts",
        "formDescription": "Review and edit AI-generated artifacts before saving. Leave any field blank to keep the AI original. Check the Review Required email for the pre-filled content to copy in.",
        "formFields": {
          "values": [
            {
              "fieldLabel": "close_date",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.close_date }}"
            },
            {
              "fieldLabel": "stage",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.stage }}"
            },
            {
              "fieldLabel": "cas",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.cas }}"
            },
            {
              "fieldLabel": "forecast_category",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.forecast_category }}"
            },
            {
              "fieldLabel": "salesforce_block_1_dap",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.salesforce_block_1_dap }}"
            },
            {
              "fieldLabel": "risks",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.risks }}"
            },
            {
              "fieldLabel": "next_step",
              "fieldType": "text",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.next_step }}"
            },
            {
              "fieldLabel": "pain_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.pain_score }}"
            },
            {
              "fieldLabel": "pain_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.pain_evidence }}"
            },
            {
              "fieldLabel": "power_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.power_score }}"
            },
            {
              "fieldLabel": "power_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.power_evidence }}"
            },
            {
              "fieldLabel": "vision_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.vision_score }}"
            },
            {
              "fieldLabel": "vision_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.vision_evidence }}"
            },
            {
              "fieldLabel": "value_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.value_score }}"
            },
            {
              "fieldLabel": "value_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.value_evidence }}"
            },
            {
              "fieldLabel": "change_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.change_score }}"
            },
            {
              "fieldLabel": "change_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.change_evidence }}"
            },
            {
              "fieldLabel": "control_score",
              "fieldType": "number",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.control_score }}"
            },
            {
              "fieldLabel": "control_evidence",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.control_evidence }}"
            },
            {
              "fieldLabel": "call_summary",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.call_summary }}"
            },
            {
              "fieldLabel": "highlights",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.highlights }}"
            },
            {
              "fieldLabel": "action_items",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.action_items }}"
            },
            {
              "fieldLabel": "p2v2c2_scoring",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.p2v2c2_scoring }}"
            },
            {
              "fieldLabel": "internal_actions",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.internal_actions }}"
            },
            {
              "fieldLabel": "services_narrative",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.services_narrative }}"
            },
            {
              "fieldLabel": "general_narrative",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.general_narrative }}"
            },
            {
              "fieldLabel": "anecdotes",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.anecdotes }}"
            },
            {
              "fieldLabel": "internal_team_update",
              "fieldType": "textarea",
              "requiredField": false,
              "defaultValue": "={{ $('Format for PostgreSQL').item.json.internal_team_update }}"
            }
          ]
        },
        "responseMode": "onReceived",
        "options": {
          "responseText": "Artifacts saved. Check your email for the final output."
        }
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        1000,
        64
      ],
      "name": "Wait for Review (Editing Portal)",
      "webhookId": "echo-artifact-review"
    },
    {
      "parameters": {
        "jsCode": "// Merge original AI outputs with edits from the review form\nconst orig = $('Format for PostgreSQL').item.json;\nconst form = $input.item.json;\n\nfunction esc(val) {\n  if (val === null || val === undefined || val === '') return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction escStr(val) {\n  if (val === null || val === undefined) return 'NULL';\n  return \"'\" + String(val).replace(/'/g, \"''\") + \"'\";\n}\nfunction escNum(val) {\n  const n = Number(val);\n  return isNaN(n) ? '0' : String(n);\n}\n\nfunction edited(formVal, origVal) {\n  const f = (formVal || '').trim();\n  return f.length > 0 ? f : (origVal || '');\n}\nfunction editedNum(formVal, origVal) {\n  const f = String(formVal || '').trim();\n  const n = Number(f);\n  return (!isNaN(n) && f.length > 0) ? n : origVal;\n}\n\n// Salesforce standalone\nconst close_date = edited(form['close_date'], orig.close_date);\nconst stage = edited(form['stage'], orig.stage);\nconst cas = edited(form['cas'], orig.cas);\nconst forecast_category = edited(form['forecast_category'], orig.forecast_category);\nconst salesforce_block_1_dap = edited(form['salesforce_block_1_dap'], orig.salesforce_block_1_dap);\nconst risks = edited(form['risks'], orig.risks);\nconst next_step = edited(form['next_step'], orig.next_step);\n\n// P2V2C2\nconst pain_score = editedNum(form['pain_score'], orig.pain_score);\nconst pain_evidence = edited(form['pain_evidence'], orig.pain_evidence);\nconst power_score = editedNum(form['power_score'], orig.power_score);\nconst power_evidence = edited(form['power_evidence'], orig.power_evidence);\nconst vision_score = editedNum(form['vision_score'], orig.vision_score);\nconst vision_evidence = edited(form['vision_evidence'], orig.vision_evidence);\nconst value_score = editedNum(form['value_score'], orig.value_score);\nconst value_evidence = edited(form['value_evidence'], orig.value_evidence);\nconst change_score = editedNum(form['change_score'], orig.change_score);\nconst change_evidence = edited(form['change_evidence'], orig.change_evidence);\nconst control_score = editedNum(form['control_score'], orig.control_score);\nconst control_evidence = edited(form['control_evidence'], orig.control_evidence);\nconst p2v2c2_total = pain_score + power_score + vision_score + value_score + change_score + control_score;\n\n// Narratives\nconst call_summary = edited(form['call_summary'], orig.call_summary);\nconst highlights = edited(form['highlights'], orig.highlights);\nconst action_items = edited(form['action_items'], orig.action_items);\nconst p2v2c2_scoring = edited(form['p2v2c2_scoring'], orig.p2v2c2_scoring);\nconst internal_actions = edited(form['internal_actions'], orig.internal_actions);\nconst services_narrative = edited(form['services_narrative'], orig.services_narrative);\nconst general_narrative = edited(form['general_narrative'], orig.general_narrative);\nconst anecdotes = edited(form['anecdotes'], orig.anecdotes);\nconst internal_team_update = edited(form['internal_team_update'], orig.internal_team_update);\n\nconst deal_slug = orig.deal.deal_slug;\n\nreturn [{\n  json: {\n    deal: orig.deal,\n    close_date, stage, cas, forecast_category,\n    salesforce_block_1_dap, risks, next_step,\n    pain_score, pain_evidence,\n    power_score, power_evidence,\n    vision_score, vision_evidence,\n    value_score, value_evidence,\n    change_score, change_evidence,\n    control_score, control_evidence,\n    p2v2c2_total,\n    call_summary, highlights, action_items, p2v2c2_scoring,\n    internal_actions, services_narrative, general_narrative,\n    anecdotes, internal_team_update\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        64
      ],
      "name": "Merge Edited Artifacts"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "check-new-opp-id",
              "leftValue": "={{ $json._contextSource?.toLowerCase().trim() }}",
              "operator": {
                "type": "string",
                "operation": "contains",
                "singleValue": "new"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1120,
        64
      ],
      "name": "Check if New Deal"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.insertDealSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1280,
        -32
      ],
      "name": "Insert New Deal",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.updateDealSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1280,
        160
      ],
      "name": "Update Existing Deal",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Merge Edited Artifacts').item.json.saveArtifactsSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1440,
        64
      ],
      "name": "Save Artifacts",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Merge Edited Artifacts').item.json.saveFeedbackSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1440,
        208
      ],
      "name": "Save Artifact Feedback",
      "continueOnFail": true,
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Format for PostgreSQL').item.json.saveEvidenceSQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1584,
        64
      ],
      "name": "Save P2V2C2 Evidence",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Format for PostgreSQL').item.json.saveHistorySQL }}",
        "options": {
          "queryBatching": "independently"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1728,
        64
      ],
      "name": "Save History",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge both trigger sources\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -752,
        160
      ],
      "name": "Merge Triggers"
    },
    {
      "parameters": {
        "sendTo": "austin.holland@clearwatersecurity.com",
        "subject": "Deal Path Artifacts Notification",
        "message": "=<h2>Deal Path Artifacts \u2014 Final (Reviewed)</h2>\n\n<p><strong>Deal:</strong> {{ $('Merge Edited Artifacts').item.json.deal.deal_slug }}</p>\n<p><strong>Opportunity:</strong> {{ $('Merge Edited Artifacts').item.json.deal.opportunity_name }}</p>\n<p><strong>Date:</strong> {{ $('Input Classifier').item.json.date }}</p>\n<p><strong>Input Type:</strong> {{ $('Input Classifier').item.json.input_type }}</p>\n\n<h3>CAS Stage</h3>\n<p><strong>Current:</strong> {{ $('Merge Edited Artifacts').item.json.deal.cas_current }}</p>\n<p><strong>Next:</strong> {{ $('Merge Edited Artifacts').item.json.deal.cas_next }}</p>\n\n<hr>\n\n<h3>Artifacts (Reviewed &amp; Approved)</h3>\n\n<h4>Client Follow-Up Email</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">{{ $('Merge Edited Artifacts').item.json.client_follow_up_email }}</pre>\n\n<h4>Salesforce DAP Block</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">{{ $('Merge Edited Artifacts').item.json.salesforce_block_1_dap }}</pre>\n\n<h4>Salesforce P2V2C2</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">Pain ({{ $('Merge Edited Artifacts').item.json.pain_score }}/5): {{ $('Merge Edited Artifacts').item.json.pain_evidence }}\n\nPower ({{ $('Merge Edited Artifacts').item.json.power_score }}/5): {{ $('Merge Edited Artifacts').item.json.power_evidence }}\n\nVision ({{ $('Merge Edited Artifacts').item.json.vision_score }}/5): {{ $('Merge Edited Artifacts').item.json.vision_evidence }}\n\nValue ({{ $('Merge Edited Artifacts').item.json.value_score }}/5): {{ $('Merge Edited Artifacts').item.json.value_evidence }}\n\nChange ({{ $('Merge Edited Artifacts').item.json.change_score }}/5): {{ $('Merge Edited Artifacts').item.json.change_evidence }}\n\nControl ({{ $('Merge Edited Artifacts').item.json.control_score }}/5): {{ $('Merge Edited Artifacts').item.json.control_evidence }}\n\nTotal: {{ $('Merge Edited Artifacts').item.json.p2v2c2_total }}/30</pre>\n\n<h4>Executive Recap</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">{{ $('Merge Edited Artifacts').item.json.exec_recap_forwardable }}</pre>\n\n<h4>Internal Message - Pricing</h4>\n<pre style=\"background:#f5f5f5; padding:15px; border-radius:5px; white-space:pre-wrap;\">{{ $('Merge Edited Artifacts').item.json.internal_message_pricing }}</pre>",
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        1872,
        160
      ],
      "name": "Gmail - Send Artifacts Email",
      "webhookId": "d41f4808-1611-40bf-b933-cb7ec9b596ad",
      "credentials": {
        "gmailOAuth2": {
          "id": "KcxcROH9oa3L7IUB",
          "name": "Gmail ECHO"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "check-deal-found",
              "leftValue": "={{ $('Load Deal Memory').item.json.id }}",
              "operator": {
                "type": "string",
                "operation": "exists"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -288,
        240
      ],
      "name": "Check Deal Exists"
    },
    {
      "parameters": {
        "jsCode": "// Initialize a new opportunity when deal doesn't exist\nconst input = $('Input Classifier').item.json;\n\nconst newDeal = {\n  json: {\n    kind: 'deal_record',\n    deal_slug: input.deal_slug,\n    salesforce_opportunity_id: null,\n    _contextSource: 'new_opportunity',\n    outputs_version: 'v2',\n    content: input.content || `New deal opportunity: ${input.opportunity_name || 'unnamed'} at ${input.account_name || 'unknown account'}. Expected close: ${input.close_date || 'TBD'}`,\n    input_type: input.input_type || 'deal_intake',\n    \n    updated_at: new Date().toISOString(),\n    \n    opportunity_name: '',\n    account_name: '',\n    cas_current: '1A: Discovery - Initial conversation',\n    cas_next: '1B: Discovery - Problem validation',\n    cas_confidence: 'low',\n    \n    pain_score: 0,\n    power_score: 0,\n    vision_score: 0,\n    value_score: 0,\n    change_score: 0,\n    control_score: 0\n  }\n};\n\nreturn [newDeal];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        224
      ],
      "name": "Create New Opportunity",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst dealContext = items[0];\nconst contextSource = dealContext.json._contextSource || 'unknown';\n\nconsole.log('Merge Deal Context - contextSource:', contextSource);\n\nreturn [{\n  json: {\n    ...dealContext.json,\n    _contextSource: contextSource\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        80
      ],
      "name": "Merge Deal Context"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        400,
        288
      ],
      "name": "GPT-4o Agent 1",
      "credentials": {
        "openAiApi": {
          "id": "fIeGh1UabUL1CBma",
          "name": "ECHO OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "model": "text-embedding-3-small",
        "options": {
          "baseURL": "https://api.openai.com/v1"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1,
      "position": [
        240,
        560
      ],
      "name": "OpenAI Embeddings",
      "credentials": {
        "openAiApi": {
          "id": "fIeGh1UabUL1CBma",
          "name": "ECHO OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "mode": "retrieve-as-tool",
        "toolName": "clearwater_knowledge_base",
        "toolDescription": "Search Clearwater's CPS methodology (P2V2C2 scoring rubric 0-5 definitions, DAP structure, sales stages Discover/Qualify/Prove/Negotiate/Close, Champion/PES/ES/DM role definitions) and Clearwater's full service catalog (MSS, MDR, Risk Analysis, IRM|Pro, ClearAdvantage, vCISO, Privacy & Compliance, Technical Testing, etc.). Use this tool to look up scoring criteria, service terminology, and sales process definitions.",
        "tableName": "n8n_vectors",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePGVector",
      "typeVersion": 1.3,
      "position": [
        240,
        480
      ],
      "name": "ECHO Knowledge Base (PGVector)",
      "credentials": {
        "postgres": {
          "id": "ZMNqF3gUEXvNCjht",
          "name": "ECHO PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Assemble structured context for ECHO Artifact Engine from Agent 1 output\nconst agent1 = $('ECHO Intelligence Engine').item.json;\nconst input = $('Input Classifier').item.json;\nconst dealContext = $('Merge Deal Context').item.json;\n\nfunction unwrap(node) {\n  const raw = node.output !== undefined ? node.output : node;\n  if (typeof raw === 'string') {\n    try {\n      const cleaned = raw.replace(/^```json\\s*/i, '').replace(/^```\\s*/i, '').replace(/```\\s*$/i, '').trim();\n      return JSON.parse(cleaned);\n    } catch(e) { return {}; }\n  }\n  return raw;\n}\n\nconst data1 = unwrap(agent1);\nconst sf = data1.salesforce || {};\nconst ev = data1.evidence || {};\n\n// Build a rich context block for Agent 2\nconst contextBlock = `DEAL CONTEXT FOR ARTIFACT ENGINE\n==================================\nDeal: ${input.deal_slug || 'unknown'}\nAccount: ${input.account_name || dealContext?.account_name || 'unknown'}\nInput Type: ${input.input_type || 'unknown'}\nDate: ${input.date || 'unknown'}\n\nEVIDENCE DOCUMENT (verbatim speaker-attributed quotes from Intelligence Engine)\n---\nPain Evidence:\n${ev.pain || 'No evidence found.'}\n\nPower Evidence:\n${ev.power || 'No evidence found.'}\n\nVision Evidence:\n${ev.vision || 'No evidence found.'}\n\nValue Evidence:\n${ev.value || 'No evidence found.'}\n\nChange Evidence:\n${ev.change || 'No evidence found.'}\n\nControl Evidence:\n${ev.control || 'No evidence found.'}\n\nP2V2C2 SCORES (from Intelligence Engine)\n---\nPain: ${sf.pain_score || 0}/5 \u2014 ${sf.pain_evidence || ''}\nPower: ${sf.power_score || 0}/5 \u2014 ${sf.power_evidence || ''}\nVision: ${sf.vision_score || 0}/5 \u2014 ${sf.vision_evidence || ''}\nValue: ${sf.value_score || 0}/5 \u2014 ${sf.value_evidence || ''}\nChange: ${sf.change_score || 0}/5 \u2014 ${sf.change_evidence || ''}\nControl: ${sf.control_score || 0}/5 \u2014 ${sf.control_evidence || ''}\n\nPHASE 1 SALESFORCE ARTIFACTS (from Intelligence Engine)\n---\nClose Date: ${sf.close_date || 'TBD'}\nStage: ${sf.stage || 'unknown'}\nCAS: ${sf.cas || 'unknown'}\nForecast Category: ${sf.forecast_category || 'unknown'}\nRisks: ${sf.risks || 'none noted'}\nNext Step: ${sf.next_step || 'none noted'}\n\nDAP Block:\n${sf.salesforce_block_1_dap || 'Not yet generated.'}\n\nPRIOR DEAL HISTORY\n---\n${dealContext?.cas_current ? 'Prior CAS: ' + dealContext.cas_current : 'First run \u2014 no prior history.'}\n\nRAW INPUT\n---\n${(input.content || '').substring(0, 8000)}`;\n\nreturn [{ json: { content: contextBlock } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        656,
        64
      ],
      "name": "Prepare Agent 2 Input",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.content }}",
        "options": {
          "systemMessage": "IDENTITY\nYou are ECHO Artifact Engine \u2014 the narrative intelligence layer for Austin Holland, Sales Executive at Clearwater Security & Compliance, PPM team. You receive a fully analyzed deal record from ECHO Intelligence Engine (evidence, P2V2C2 scores, Phase 1 Salesforce artifacts) and produce polished Phase 2 narrative artifacts.\n\nYour input is a structured deal record containing:\n- Raw evidence document (speaker-attributed verbatim quotes organized by P2V2C2 dimension)\n- P2V2C2 scores with evidence descriptions\n- Phase 1 Salesforce artifacts (close date, stage, CAS, DAP block, risks, next step)\n- Full deal history (all prior runs)\n\nKNOWLEDGE TOOLS\nUse the clearwater_knowledge_base tool to ensure all service descriptions use correct Clearwater terminology (MSS, MDR, IRM|Analysis, IRM|Pro, ClearAdvantage, vCISO, Technical Testing, Privacy & Compliance, etc.).\n\nTASK \u2014 PHASE 2: NARRATIVE ARTIFACTS\n\nProduce all nine narrative artifacts with high quality, specific language grounded in the evidence.\n\n1) call_summary: Concise summary of the call/email/discussion \u2014 what happened, who participated, key outcomes.\n\n2) highlights: Bullet-point highlights of what was discussed \u2014 the 5-7 most important moments or statements.\n\n3) action_items: Next steps \u2014 both explicitly mentioned and logically expected given the deal stage. Format as actionable items with owners where known.\n\n4) p2v2c2_scoring: A narrative interpretation of the P2V2C2 scores \u2014 not a table, but a written assessment of where the deal stands, what's strong, what's exposed, and why each score was assigned.\n\n5) internal_actions: Internal-only action items \u2014 what Austin or the Clearwater team needs to prepare, research, or produce to advance the deal. Predicted outputs needed to perpetuate the deal cycle as quickly as possible.\n\n6) services_narrative: All specific services, workstreams, engagements, or products mentioned or established throughout the deal cycle. Include scope, timing, quantities, unknowns, named colleagues, and client sentiment toward proposed solutions. Use exact Clearwater service names.\n\n7) general_narrative: A full narrative of all inputs \u2014 all correspondence, both with prospect and internally \u2014 ending with a conclusion on how to best close the highest possible TCV given the full deal context.\n\n8) anecdotes: Any other notable observations, behavioral patterns, cultural signals, or artifacts from the input that could aid future deal insights.\n\n9) internal_team_update: **Tone: Astute, eloquent, professional, with subtle dry sarcasm on corporate behaviors or delays.**\n\nStructure:\nOpportunity Source: (Where did this come from?)\nDAP Review: (Brief status check)\nCurrent/Future State Narrative: (No bullets \u2014 weave the facts into a narrative story about the client's plight and their likely path to a desired future state.)\nP2V2C2 Strengths & Weaknesses: (Where are we strong, where are we exposed?)\nWinning Strategy: (How we close this)\nLeadership Help: (Ask for specific help if needed; otherwise state \"under control\")\n\nOUTPUT FORMAT\nReturn ONLY the following JSON object \u2014 no preamble, no markdown fences:\n{\n  \"narratives\": {\n    \"call_summary\": \"\",\n    \"highlights\": \"\",\n    \"action_items\": \"\",\n    \"p2v2c2_scoring\": \"\",\n    \"internal_actions\": \"\",\n    \"services_narrative\": \"\",\n    \"general_narrative\": \"\",\n    \"anecdotes\": \"\",\n    \"internal_team_update\": \"\"\n  }\n}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        848,
        64
      ],
      "name": "ECHO Artifact Engine",
      "alwaysOutputData": true,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "options": {
          "temperature": 0.5
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        864,
        288
      ],
      "name": "GPT-4o Agent 2",
      "credentials": {
        "openAiApi": {
          "id": "fIeGh1UabUL1CBma",
          "name": "ECHO OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsonSchemaExample": "={{ {} }}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        992,
        288
      ],
      "name": "Structured Output Parser Agent 2"
    }
  ],
  "connections": {
    "Gmail Trigger - Deal Inputs": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Triggers": {
      "main": [
        [
          {
            "node": "Input Classifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Input Classifier": {
      "main": [
        [
          {
            "node": "Load Deal Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Deal Memory": {
      "main": [
        [
          {
            "node": "Validate Deal Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Deal Memory": {
      "main": [
        [
          {
            "node": "Check Deal Exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format for PostgreSQL": {
      "main": [
        [
          {
            "node": "Open Review Portal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Review (Editing Portal)": {
      "main": [
        [
          {
            "node": "Merge Edited Artifacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Edited Artifacts": {
      "main": [
        [
          {
            "node": "Check if New Deal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if New Deal": {
      "main": [
        [
          {
            "node": "Insert New Deal",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Existing Deal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert New Deal": {
      "main": [
        [
          {
            "node": "Save Artifacts",
            "type": "main",
            "index": 0
          },
          {
            "node": "Save Artifact Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Existing Deal": {
      "main": [
        [
          {
            "node": "Save Artifacts",
            "type": "main",
            "index": 0
          },
          {
            "node": "Save Artifact Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Artifacts": {
      "main": [
        [
          {
            "node": "Save P2V2C2 Evidence",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save P2V2C2 Evidence": {
      "main": [
        [
          {
            "node": "Save History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save History": {
      "main": [
        [
          {
            "node": "Gmail - Send Artifacts Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Deal Exists": {
      "main": [
        [
          {
            "node": "Merge Deal Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Opportunity",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New Opportunity": {
      "main": [
        [
          {
            "node": "Merge Deal Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Open Review Portal": {
      "main": [
        [
          {
            "node": "Wait for Review (Editing Portal)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Embeddings": {
      "ai_embedding": [
        [
          {
            "node": "ECHO Knowledge Base (PGVector)",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "ECHO Knowledge Base (PGVector)": {
      "ai_tool": [
        [
          {
            "node": "ECHO Intelligence Engine",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Merge Deal Context": {
      "main": [
        [
          {
            "node": "ECHO Intelligence Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ECHO Intelligence Engine": {
      "main": [
        [
          {
            "node": "Prepare Agent 2 Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser Agent 1": {
      "ai_outputParser": [
        [
          {
            "node": "ECHO Intelligence Engine",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "GPT-4o Agent 1": {
      "ai_languageModel": [
        [
          {
            "node": "ECHO Intelligence Engine",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Agent 2 Input": {
      "main": [
        [
          {
            "node": "ECHO Artifact Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ECHO Artifact Engine": {
      "main": [
        [
          {
            "node": "Format for PostgreSQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GPT-4o Agent 2": {
      "ai_languageModel": [
        [
          {
            "node": "ECHO Artifact Engine",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser Agent 2": {
      "ai_outputParser": [
        [
          {
            "node": "ECHO Artifact Engine",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "binaryMode": "separate"
  },
  "tags": [],
  "active": true,
  "isArchived": false
}